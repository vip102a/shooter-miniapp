<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Survival Shooter ‚Äì Mini App</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #000;
    }
    body {
      display: flex;
      justify-content: center;
      align-items: stretch;
    }
    #root {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(circle at top, #131b36 0%, #040716 55%, #020308 100%);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    #topBar {
      position: absolute;
      top: 4px;
      left: 4px;
      right: 4px;
      display: flex;
      gap: 6px;
      align-items: center;
      justify-content: flex-start;
      z-index: 5;
      pointer-events: none;
    }
    .chip {
      pointer-events: auto;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      border-radius: 999px;
      padding: 4px 9px;
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.35);
    }
    .chip .label {
      opacity: .8;
    }
    .chip-button {
      cursor: pointer;
      user-select: none;
    }
    #hpBarWrap {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      pointer-events: auto;
    }
    #hpBarOuter {
      width: 120px;
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      overflow: hidden;
    }
    #hpBarInner {
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, #43ff6a, #25d34a);
    }
    #gunChip {
      margin-left: auto;
    }
    #gameCanvas {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }
    #pauseBtn {
      position: absolute;
      left: 10px;
      top: 32px;
      z-index: 5;
      pointer-events: auto;
    }
    #pauseBtnInner {
      background: rgba(0,0,0,0.7);
      color: #fff;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.35);
      cursor: pointer;
      user-select:none;
    }
    #bottomSkill {
      position: absolute;
      right: 10px;
      bottom: 18px;
      z-index: 5;
      pointer-events: auto;
    }
    #fireBtn {
      background: rgba(0,0,0,0.75);
      border-radius: 999px;
      padding: 6px 12px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      user-select: none;
      color:#fff;
      box-shadow: 0 6px 16px rgba(0,0,0,0.5);
      font-size: 11px;
    }
    #fireBtn span.count {
      font-weight: 600;
    }

    .overlay {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top, rgba(15,18,40,0.94), rgba(2,3,10,0.96));
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    .overlay.visible {
      display: flex;
    }
    .panel {
      width: min(420px, 90vw);
      max-height: 90vh;
      background: rgba(0,0,0,0.82);
      border-radius: 18px;
      padding: 14px;
      color:#fff;
      box-shadow:0 12px 30px rgba(0,0,0,0.7);
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .panel h2 {
      margin: 0 0 4px;
      font-size: 18px;
    }
    .panel p {
      margin: 0 0 8px;
      font-size: 13px;
      opacity: .9;
    }
    .panel-row {
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-bottom:4px;
    }
    .btn {
      border:none;
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      cursor:pointer;
      background:#ffb100;
      color:#201317;
      font-weight:600;
      box-shadow:0 4px 12px rgba(0,0,0,0.5);
      display:inline-flex;
      align-items:center;
      gap:4px;
      user-select:none;
    }
    .btn.secondary {
      background:rgba(255,255,255,0.1);
      color:#fff;
      box-shadow:none;
    }
    .btn.full {
      width:100%;
      justify-content:center;
    }
    .shop-section-title {
      font-size:13px;
      font-weight:600;
      margin-top:4px;
      margin-bottom:4px;
      opacity:.95;
    }
    .shop-item {
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:5px 0;
      border-bottom:1px solid rgba(255,255,255,0.06);
      font-size:12px;
    }
    .shop-item:last-child { border-bottom:none; }
    .shop-item .meta {
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .shop-item .meta span.desc {
      opacity:.8;
      font-size:11px;
    }

    #toast {
      position:absolute;
      left:50%;
      bottom:60px;
      transform:translateX(-50%);
      background:rgba(0,0,0,0.85);
      color:#fff;
      font-size:11px;
      padding:6px 10px;
      border-radius:999px;
      opacity:0;
      pointer-events:none;
      transition:opacity .2s;
      z-index:30;
      white-space:nowrap;
    }
    #toast.visible {
      opacity:1;
    }
  </style>
</head>
<body>
<div id="root">
  <canvas id="gameCanvas" width="480" height="800"></canvas>

  <div id="topBar">
    <div class="chip" id="stageChip">
      <span class="label">Stage</span>
      <span id="stageValue">1</span>
    </div>
    <div class="chip" id="hpChip">
      <span class="label">HP</span>
      <div id="hpBarWrap">
        <div id="hpBarOuter">
          <div id="hpBarInner"></div>
        </div>
      </div>
      <span id="hpValue" style="font-weight:600;">100</span>
    </div>
    <div class="chip" id="goldChip">
      <span class="label">Gold</span>
      <span id="goldValue" style="font-weight:600;">0</span>
    </div>
    <div class="chip chip-button" id="gunChip">
      <div style="display:flex;flex-direction:column;align-items:flex-start;gap:0;">
        <span id="weaponName" style="font-size:11px;font-weight:600;">Pistol</span>
        <span id="weaponLevel" style="font-size:10px;opacity:.85;">Lv.1</span>
      </div>
      <span style="font-size:11px;opacity:.8;">üîÑ</span>
    </div>
    <div class="chip chip-button" id="shopChip">
      <span>üõí Shop</span>
    </div>
  </div>

  <div id="pauseBtn">
    <div id="pauseBtnInner">‚è∏ T·∫°m d·ª´ng</div>
  </div>

  <div id="bottomSkill">
    <div id="fireBtn">
      <span>üî• B√£o l·ª≠a</span>
      <span class="count" id="fireCount">0</span>
    </div>
  </div>

  <!-- Overlay: Pause / Menu -->
  <div class="overlay" id="menuOverlay">
    <div class="panel">
      <h2 id="menuTitle">Survival Shooter</h2>
      <p id="menuDesc">
        Di chuy·ªÉn nh√¢n v·∫≠t kh·∫Øp m√†n h√¨nh ƒë·ªÉ n√© ƒë·∫°n, auto-b·∫Øn ti√™u di·ªát qu√°i. D√πng Gold ƒë·ªÉ n√¢ng c·∫•p, d√πng Stars ƒë·ªÉ mua Gold.
      </p>
      <div class="panel-row">
        <button class="btn full" id="btnResume">‚ñ∂ Ti·∫øp t·ª•c</button>
      </div>
      <div class="panel-row">
        <button class="btn full secondary" id="btnRestart">üîÅ Ch∆°i l·∫°i t·ª´ Stage 1</button>
      </div>
    </div>
  </div>

  <!-- Overlay: Shop -->
  <div class="overlay" id="shopOverlay">
    <div class="panel">
      <h2>üõí Shop</h2>
      <p>Gold ƒëang c√≥: <b><span id="shopGoldDisplay">0</span></b><br/>
         1 ‚≠ê = 10 Gold. D√πng Stars ƒë·ªÉ mua Gold, r·ªìi d√πng Gold ƒë·ªÉ n√¢ng c·∫•p trong game.
      </p>

      <div class="shop-section-title">A. ƒê·ªïi Stars ‚ûú Gold</div>
      <div class="panel-row" style="max-height:110px;overflow:auto;">
        <!-- c√°c g√≥i stars -->
        <button class="btn" data-stars="5">5‚≠ê ‚Üí 50G</button>
        <button class="btn" data-stars="10">10‚≠ê ‚Üí 100G</button>
        <button class="btn" data-stars="20">20‚≠ê ‚Üí 200G</button>
        <button class="btn" data-stars="50">50‚≠ê ‚Üí 500G</button>
        <button class="btn" data-stars="100">100‚≠ê ‚Üí 1000G</button>
        <button class="btn" data-stars="200">200‚≠ê ‚Üí 2000G</button>
        <button class="btn" data-stars="500">500‚≠ê ‚Üí 5000G</button>
        <button class="btn" data-stars="1000">1000‚≠ê ‚Üí 10000G</button>
      </div>

      <div class="shop-section-title">B. Shop v·∫≠t ph·∫©m (Gold)</div>
      <div id="goldShopItems">
        <!-- Heal -->
        <div class="shop-item">
          <div class="meta">
            <span>üíä H·ªìi 50 HP</span>
            <span class="desc">Mua 1 l·∫ßn: +50 HP (t·ªëi ƒëa kh√¥ng v∆∞·ª£t qu√° HP t·ªëi ƒëa).</span>
          </div>
          <button class="btn secondary" data-gitem="heal">20G</button>
        </div>
        <!-- Armor -->
        <div class="shop-item">
          <div class="meta">
            <span>üõ°Ô∏è Gi√°p vƒ©nh vi·ªÖn +20 HP</span>
            <span class="desc">TƒÉng HP t·ªëi ƒëa +20 v√† h·ªìi ngay +20 HP.</span>
          </div>
          <button class="btn secondary" data-gitem="armor">40G</button>
        </div>
        <!-- Continue -->
        <div class="shop-item">
          <div class="meta">
            <span>üîÅ Ch∆°i ti·∫øp khi thua</span>
            <span class="desc">Ch·ªâ d√πng sau khi thua 1 m√†n, h·ªìi full HP.</span>
          </div>
          <button class="btn secondary" data-gitem="continue">60G</button>
        </div>
        <!-- Firestorm -->
        <div class="shop-item">
          <div class="meta">
            <span>üî• B√£o l·ª≠a x3</span>
            <span class="desc">Qu√©t s·∫°ch ƒë·∫°n qu√°i + 10% m√°u to√†n b·ªô qu√°i m·ªói l·∫ßn d√πng.</span>
          </div>
          <button class="btn secondary" data-gitem="firestorm">40G</button>
        </div>
      </div>

      <div class="shop-section-title">C. V≈© kh√≠</div>
      <div id="weaponShop"></div>

      <div class="panel-row" style="margin-top:8px;">
        <button class="btn full secondary" id="btnCloseShop">ƒê√≥ng Shop</button>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div id="toast"></div>
</div>

<script>
  const BACKEND_URL = 'https://backend-yemh.onrender.com';
  const GOLD_PER_STAR = 10;

  const tg = window.Telegram?.WebApp;
  if (tg) {
    tg.expand();
    tg.ready();
  }

  // ================== AUDIO ENGINE (gi·ªëng soundtest, shot tr·∫ßm h∆°n) ==================
  let audioCtx = null;
  let masterGain = null;
  let audioEnabled = false;

  function initAudio() {
    if (audioCtx) {
      if (audioCtx.state === 'suspended') audioCtx.resume();
      audioEnabled = true;
      return;
    }
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.7;
      masterGain.connect(audioCtx.destination);
      audioEnabled = true;
    } catch (e) {
      console.error('Audio init error:', e);
      audioEnabled = false;
    }
  }
  function ensureAudio() {
    if (!audioEnabled) initAudio();
    return audioEnabled;
  }
  function playNoise(duration, opts = {}) {
    if (!ensureAudio() || !audioCtx || !masterGain) return;
    const bufferSize = audioCtx.sampleRate * duration;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
    }
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;

    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;
    const vol = opts.volume != null ? opts.volume : 0.4;

    src.connect(gain);
    gain.connect(masterGain);

    gain.gain.setValueAtTime(vol, now);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    src.start(now);
    src.stop(now + duration + 0.05);
  }
  function playTone(freq, duration, opts = {}) {
    if (!ensureAudio() || !audioCtx || !masterGain) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    const now = audioCtx.currentTime;
    const type = opts.type || 'sine';
    const vol  = opts.volume != null ? opts.volume : 0.4;

    osc.type = type;
    osc.frequency.setValueAtTime(freq, now);

    osc.connect(gain);
    gain.connect(masterGain);

    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.linearRampToValueAtTime(vol, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    osc.start(now);
    osc.stop(now + duration + 0.05);
  }
  function playSweep(startFreq, endFreq, duration, opts = {}) {
    if (!ensureAudio() || !audioCtx || !masterGain) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;

    const type = opts.type || 'sawtooth';
    const vol  = opts.volume != null ? opts.volume : 0.35;

    osc.type = type;
    osc.frequency.setValueAtTime(startFreq, now);
    osc.frequency.linearRampToValueAtTime(endFreq, now + duration);

    osc.connect(gain);
    gain.connect(masterGain);

    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.linearRampToValueAtTime(vol, now + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    osc.start(now);
    osc.stop(now + duration + 0.05);
  }

  function sfxPlayerHit() {
    playSweep(220, 120, 0.18, { type: 'triangle', volume: 0.45 });
    setTimeout(() => {
      playTone(90, 0.08, { type: 'sine', volume: 0.35 });
    }, 130);
  }
  function sfxStageClearLaugh() {
    const pattern = [
      { f: 380, d: 0.09 },
      { f: 520, d: 0.09 },
      { f: 660, d: 0.12 },
      { f: 580, d: 0.12 },
      { f: 720, d: 0.16 },
    ];
    let delay = 0;
    pattern.forEach((note) => {
      setTimeout(() => playTone(note.f, note.d, { type: 'square', volume: 0.38 }), delay);
      delay += note.d * 700;
    });
  }
  function sfxEnemyDie() {
    playSweep(650, 900, 0.12, { type: 'sawtooth', volume: 0.35 });
    setTimeout(() => playNoise(0.08, { volume: 0.22 }), 40);
  }
  function sfxBossDie() {
    playSweep(620, 980, 0.22, { type: 'triangle', volume: 0.4 });
    setTimeout(() => {
      if (!ensureAudio() || !audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';

      osc.frequency.setValueAtTime(700, audioCtx.currentTime);
      osc.frequency.linearRampToValueAtTime(480, audioCtx.currentTime + 0.35);

      osc.connect(gain);
      gain.connect(masterGain);

      const g = gain.gain;
      const t0 = audioCtx.currentTime;
      g.setValueAtTime(0.0001, t0);
      g.linearRampToValueAtTime(0.32, t0 + 0.02);
      g.exponentialRampToValueAtTime(0.0001, t0 + 0.38);

      osc.start(t0);
      osc.stop(t0 + 0.42);
    }, 180);
    setTimeout(() => playNoise(0.18, { volume: 0.26 }), 130);
  }
  function sfxGameOverTease() {
    const groups = [
      { freqs: [760, 840, 880], gap: 55 },
      { freqs: [800, 880, 920], gap: 55 },
      { freqs: [840, 920, 960], gap: 55 },
    ];
    let baseDelay = 0;
    groups.forEach((g) => {
      g.freqs.forEach((f, idx) => {
        setTimeout(() => playTone(f, 0.07, { type: 'square', volume: 0.34 }), baseDelay + idx * g.gap);
      });
      setTimeout(() => {
        playSweep(g.freqs[g.freqs.length - 1],
                  g.freqs[g.freqs.length - 1] + 140,
                  0.09,
                  { type: 'triangle', volume: 0.28 });
      }, baseDelay + g.freqs.length * g.gap + 20);
      baseDelay += g.freqs.length * g.gap + 140;
    });
    setTimeout(() => playSweep(780, 360, 0.42, { type: 'sawtooth', volume: 0.32 }), baseDelay + 80);
    setTimeout(() => playNoise(0.12, { volume: 0.22 }), baseDelay + 350);
  }
  // Shot: 1 vi√™n, tr·∫ßm h∆°n, ƒë·ª° ch√≥i
  function sfxShot() {
    playNoise(0.05, { volume: 0.3 });
    playTone(420, 0.06, { type: 'square', volume: 0.25 });
  }
  function sfxExplosion() {
    playNoise(0.25, { volume: 0.4 });
    setTimeout(() => playSweep(220, 80, 0.25, { type:'triangle', volume:0.3 }), 10);
  }
  function sfxHit() {
    playTone(500, 0.06, { type:'sawtooth', volume:0.3 });
  }

  // =============== GAME CORE ===============
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const scaleX = rect.width / canvas.width;
    const scaleY = rect.height / canvas.height;
    canvas._scaleX = scaleX;
    canvas._scaleY = scaleY;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Sky stars background
  const skyStars = [];
  for (let i = 0; i < 80; i++) {
    skyStars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      r: Math.random() * 1.3 + 0.5,
      speed: Math.random() * 20 + 10,
      alpha: Math.random() * 0.7 + 0.3
    });
  }

  const playerImg = new Image();
  playerImg.src = 'player.png';
  const enemyImg = new Image();
  enemyImg.src = 'enemy_girl.png';
  const bossImg = new Image();
  bossImg.src = 'boss_girl.png';

  const player = {
    x: canvas.width / 2,
    y: canvas.height - 80,
    width: 40,
    height: 64,
    speed: 260,
    hp: 100,
    maxHp: 100,
    alive: true
  };

  let currentStage = 1;
  let enemies = [];
  let bullets = [];
  let enemyBullets = [];
  let gold = 0;
  let firestormCount = 0;
  let gameState = 'playing'; // 'playing' | 'menu' | 'gameover' | 'stageclear'
  let paused = false;
  let canContinue = false;

  // weapons
  const weapons = [
    { id:'pistol', name:'Pistol', owned:true, level:1, maxLevel:10,
      baseDmg:12, baseRate:0.40, bulletSpeed:420 },
    { id:'rifle', name:'Rifle', owned:false, level:1, maxLevel:10,
      baseDmg:9, baseRate:0.20, bulletSpeed:520 },
    { id:'shotgun', name:'Shotgun', owned:false, level:1, maxLevel:8,
      baseDmg:8, baseRate:0.55, bulletSpeed:380, pellets:4 },
    { id:'sniper', name:'Sniper', owned:false, level:1, maxLevel:20,
      baseDmg:55, baseRate:0.90, bulletSpeed:900, pierce:true }
  ];
  let currentWeaponIndex = 0;
  let shootCooldown = 0;

  const keys = {};
  let pointerActive = false;
  let pointerTarget = null;

  let fireworks = [];

  function showToast(msg, ms=1500) {
    const el = document.getElementById('toast');
    el.textContent = msg;
    el.classList.add('visible');
    clearTimeout(el._t);
    el._t = setTimeout(() => el.classList.remove('visible'), ms);
  }

  // ========== SPAWN ENEMIES ==========
  function spawnStage(stage) {
    enemies = [];
    enemyBullets = [];
    bullets = [];
    fireworks = [];

    const baseCount = 8 + (stage - 1) * 4;
    const hpBase = 40 + (stage - 1) * 12;
    const dmgBase = 8 + (stage - 1) * 2;

    for (let i=0;i<baseCount;i++) {
      const row = Math.floor(i / 6);
      const col = i % 6;
      const paddingX = 40;
      const spacingX = (canvas.width - paddingX*2) / 5;
      enemies.push({
        x: paddingX + spacingX * col,
        y: 70 + row * 70,
        width: 36,
        height: 56,
        hp: hpBase,
        maxHp: hpBase,
        dmg: dmgBase,
        isBoss:false,
        shootCooldown: Math.random()*2 + 1.2
      });
    }

    if (stage % 3 === 0) {
      enemies.push({
        x: canvas.width/2,
        y: 60,
        width: 52,
        height: 80,
        hp: hpBase*4,
        maxHp: hpBase*4,
        dmg: dmgBase*2,
        isBoss:true,
        shootCooldown: 0.9
      });
    }
  }

  function resetGame() {
    currentStage = 1;
    player.hp = player.maxHp = 100;
    player.x = canvas.width/2;
    player.y = canvas.height-80;
    player.alive = true;
    canContinue = false;
    spawnStage(currentStage);
    gameState = 'playing';
    paused = false;
    updateUI();
  }

  // ======= INPUT =======
  window.addEventListener('keydown', (e) => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].includes(e.key)) {
      e.preventDefault();
      keys[e.key.toLowerCase()] = true;
      initAudio();
    }
  });
  window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  canvas.addEventListener('pointerdown', (e) => {
    initAudio();
    pointerActive = true;
    pointerTarget = getCanvasPos(e);
  });
  canvas.addEventListener('pointermove', (e)=>{
    if (!pointerActive) return;
    pointerTarget = getCanvasPos(e);
  });
  window.addEventListener('pointerup', ()=>{
    pointerActive = false;
  });

  function getCanvasPos(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    return { x, y };
  }

  // ======= UPDATE =======
  let lastTime = performance.now();
  function loop(now) {
    const dt = Math.min((now - lastTime)/1000, 0.05);
    lastTime = now;

    if (!paused && gameState === 'playing') {
      updateGame(dt);
    }
    renderGame();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function updateGame(dt) {
    // background
    for (const s of skyStars) {
      s.y += s.speed * dt;
      if (s.y > canvas.height) {
        s.y = -5;
        s.x = Math.random() * canvas.width;
      }
    }

    // move player: keyboard
    let mvX = 0, mvY = 0;
    if (keys['a'] || keys['arrowleft']) mvX -= 1;
    if (keys['d'] || keys['arrowright']) mvX += 1;
    if (keys['w'] || keys['arrowup']) mvY -= 1;
    if (keys['s'] || keys['arrowdown']) mvY += 1;
    // pointer target
    if (pointerActive && pointerTarget) {
      const dx = pointerTarget.x - player.x;
      const dy = pointerTarget.y - player.y;
      const dist = Math.hypot(dx,dy);
      if (dist > 4) {
        const dirx = dx/dist;
        const diry = dy/dist;
        player.x += dirx * player.speed * dt;
        player.y += diry * player.speed * dt;
      }
    } else if (mvX !== 0 || mvY !== 0) {
      const len = Math.hypot(mvX,mvY) || 1;
      mvX/=len; mvY/=len;
      player.x += mvX * player.speed * dt;
      player.y += mvY * player.speed * dt;
    }
    const topLimit = 260;
    const bottomLimit = canvas.height-60;
    player.x = Math.max(20, Math.min(canvas.width-20, player.x));
    player.y = Math.max(topLimit, Math.min(bottomLimit, player.y));

    // shoot
    shootCooldown -= dt;
    if (shootCooldown <= 0) {
      shootWeapon();
    }

    // update bullets
    for (const b of bullets) {
      b.y -= b.speed * dt;
    }
    bullets = bullets.filter(b => b.y > -20);

    for (const eb of enemyBullets) {
      eb.y += eb.speed * dt;
    }
    enemyBullets = enemyBullets.filter(b => b.y < canvas.height + 20);

    // enemies
    for (const e of enemies) {
      e.shootCooldown -= dt;
      if (e.shootCooldown <= 0) {
        enemyShoot(e);
      }
    }

    // collisions: bullet -> enemy
    for (const b of bullets) {
      for (const e of enemies) {
        if (rectHit(b, e)) {
          e.hp -= b.dmg;
          sfxHit();
          b.dead = true;
          if (weapons[currentWeaponIndex].id === 'sniper') {
            // sniper pierce: bullet v·∫´n ƒëi ti·∫øp nh∆∞ng gi·∫£m dmg
            b.dmg *= 0.7;
            if (b.dmg < 5) b.dead = true;
          } else {
            break;
          }
        }
      }
    }
    bullets = bullets.filter(b => !b.dead);

    // enemy death
    let gainedGold = 0;
    const enemiesBefore = enemies.length;
    enemies = enemies.filter(e => {
      if (e.hp <= 0) {
        gainedGold += e.isBoss ? 40 : 10;
        if (e.isBoss) sfxBossDie(); else sfxEnemyDie();
        return false;
      }
      return true;
    });
    if (gainedGold>0) {
      gold += gainedGold;
      updateUI();
    }

    // enemy bullets -> player
    for (const eb of enemyBullets) {
      if (!player.alive) break;
      if (rectHit(eb, player)) {
        eb.dead = true;
        player.hp -= eb.dmg;
        sfxPlayerHit();
        if (player.hp <= 0) {
          player.hp = 0;
          player.alive = false;
          onGameOver();
        }
      }
    }
    enemyBullets = enemyBullets.filter(b => !b.dead);

    // stage clear?
    if (enemies.length === 0 && player.alive) {
      onStageClear();
    }

    // fireworks update
    for (const fw of fireworks) {
      fw.life -= dt;
      for (const p of fw.particles) {
        p.x += p.vx*dt;
        p.y += p.vy*dt;
        p.vy += 10*dt;
        p.alpha -= dt*1.2;
      }
      fw.particles = fw.particles.filter(p => p.alpha>0);
    }
    fireworks = fireworks.filter(fw => fw.life>0 && fw.particles.length>0);

    updateUI();
  }

  function rectHit(a,b) {
    return Math.abs(a.x - b.x) < (a.w + b.width)/2 &&
           Math.abs(a.y - b.y) < (a.h + b.height)/2;
  }

  function shootWeapon() {
    const w = weapons[currentWeaponIndex];
    const rateMod = 1 - (w.level-1)*0.04;
    let interval = Math.max(0.12, w.baseRate*rateMod);
    shootCooldown = interval;

    if (!player.alive) return;

    const baseX = player.x;
    const baseY = player.y - player.height/2;

    if (w.id === 'shotgun') {
      const n = w.pellets || 4;
      for (let i=0;i<n;i++) {
        const angle = (Math.random()*0.4 - 0.2);
        bullets.push({
          x: baseX + (Math.random()*10-5),
          y: baseY,
          w: 6,
          h: 12,
          speed: w.bulletSpeed,
          dmg: w.baseDmg + w.level*3,
          angle
        });
      }
    } else {
      bullets.push({
        x: baseX,
        y: baseY,
        w: 6,
        h: 14,
        speed: w.bulletSpeed,
        dmg: w.baseDmg + w.level*4,
        angle:0
      });
    }
    sfxShot();
  }

  function enemyShoot(e) {
    e.shootCooldown = (Math.random()*1 + 1.2);
    const speed = 160 + currentStage*10;
    enemyBullets.push({
      x: e.x,
      y: e.y + e.height/2,
      w: 6,
      h: 10,
      speed,
      dmg: e.dmg
    });
  }

  function onStageClear() {
    gameState = 'stageclear';
    paused = true;
    currentStage++;
    sfxStageClearLaugh();
    spawnFireworks();
    showMenuOverlay('üéâ Stage Clear',
      'B·∫°n ƒë√£ d·ªçn s·∫°ch k·∫ª ƒë·ªãch. Nh·∫•n "Ti·∫øp t·ª•c" ƒë·ªÉ sang stage ' + currentStage + '.');
  }

  function onGameOver() {
    gameState = 'gameover';
    paused = true;
    canContinue = true;
    sfxGameOverTease();
    showMenuOverlay('üíÄ Game Over',
      'B·∫°n ƒë√£ b·ªã h·∫° g·ª•c. C√≥ th·ªÉ v√†o Shop mua "Ch∆°i ti·∫øp" ho·∫∑c ch∆°i l·∫°i t·ª´ Stage 1.');
  }

  function spawnFireworks() {
    fireworks = [];
    for (let i=0;i<7;i++) {
      const cx = Math.random()*canvas.width;
      const cy = 160 + Math.random()*120;
      const parts = [];
      for (let j=0;j<28;j++) {
        const angle = Math.random()*Math.PI*2;
        const speed = 80 + Math.random()*120;
        parts.push({
          x:cx, y:cy,
          vx: Math.cos(angle)*speed,
          vy: Math.sin(angle)*speed,
          alpha:1
        });
      }
      fireworks.push({ life:1.1, particles:parts });
    }
    sfxExplosion();
  }

  // ====== RENDER ======
  function renderGame() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // background
    ctx.fillStyle = '#02030a';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // moving stars
    for (const s of skyStars) {
      ctx.globalAlpha = s.alpha;
      ctx.fillStyle = '#dfe7ff';
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // enemies
    for (const e of enemies) {
      const img = e.isBoss ? bossImg : enemyImg;
      if (img.complete && img.width>0) {
        ctx.drawImage(img, e.x - e.width/2, e.y - e.height/2, e.width, e.height);
      } else {
        ctx.fillStyle = e.isBoss ? '#aa0066' : '#e63737';
        ctx.fillRect(e.x - e.width/2, e.y - e.height/2, e.width, e.height);
      }
      // HP bar
      const barW = e.width;
      const barH = 4;
      const hpRatio = Math.max(0, e.hp / e.maxHp);
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(e.x-barW/2, e.y - e.height/2 - 6, barW, barH);
      ctx.fillStyle = '#39ff62';
      ctx.fillRect(e.x-barW/2, e.y - e.height/2 - 6, barW*hpRatio, barH);
    }

    // player
    if (player.alive) {
      if (playerImg.complete && playerImg.width>0) {
        ctx.drawImage(playerImg, player.x - player.width/2, player.y - player.height/2,
                      player.width, player.height);
      } else {
        ctx.fillStyle = '#2af0ff';
        ctx.fillRect(player.x - player.width/2, player.y - player.height/2, player.width, player.height);
      }
    }

    // bullets
    ctx.fillStyle = '#ffdd33';
    for (const b of bullets) {
      ctx.save();
      ctx.translate(b.x, b.y);
      if (b.angle) ctx.rotate(-b.angle);
      ctx.fillRect(-b.w/2, -b.h/2, b.w, b.h);
      ctx.restore();
    }

    // enemy bullets
    ctx.fillStyle = '#ff4b4b';
    for (const eb of enemyBullets) {
      ctx.beginPath();
      ctx.arc(eb.x, eb.y, 4, 0, Math.PI*2);
      ctx.fill();
    }

    // fireworks
    for (const fw of fireworks) {
      for (const p of fw.particles) {
        ctx.globalAlpha = Math.max(0, p.alpha);
        ctx.fillStyle = '#ffdd55';
        ctx.fillRect(p.x, p.y, 3, 3);
      }
    }
    ctx.globalAlpha = 1;
  }

  // ===== UI / SHOP / STARS =====
  const stageValueEl = document.getElementById('stageValue');
  const hpValueEl = document.getElementById('hpValue');
  const hpBarInnerEl = document.getElementById('hpBarInner');
  const goldValueEl = document.getElementById('goldValue');
  const weaponNameEl = document.getElementById('weaponName');
  const weaponLevelEl = document.getElementById('weaponLevel');
  const fireCountEl = document.getElementById('fireCount');
  const shopGoldDisplayEl = document.getElementById('shopGoldDisplay');
  const weaponShopEl = document.getElementById('weaponShop');

  function updateUI() {
    stageValueEl.textContent = currentStage;
    hpValueEl.textContent = Math.round(player.hp);
    const ratio = player.hp / player.maxHp;
    hpBarInnerEl.style.width = Math.max(0, Math.min(1, ratio))*100 + '%';
    goldValueEl.textContent = gold;
    fireCountEl.textContent = firestormCount;
    shopGoldDisplayEl.textContent = gold;
    const w = weapons[currentWeaponIndex];
    weaponNameEl.textContent = w.name;
    weaponLevelEl.textContent = 'Lv.' + w.level;
    renderWeaponShop();
  }

  function renderWeaponShop() {
    weaponShopEl.innerHTML = '';
    weapons.forEach((w, idx)=>{
      const row = document.createElement('div');
      row.className = 'shop-item';
      const meta = document.createElement('div');
      meta.className = 'meta';
      const ownedText = w.owned ? 'ƒê√£ m·ªü' : 'Ch∆∞a m·ªü';
      meta.innerHTML = `<span>üî´ ${w.name} (${ownedText})</span>`;
      if (w.owned) {
        meta.innerHTML += `<span class="desc">Lv.${w.level}/${w.maxLevel} ‚Äì tƒÉng dame & t·ªëc ƒë·ªô b·∫Øn.</span>`;
      } else {
        meta.innerHTML += `<span class="desc">M·ªü kho√° v≈© kh√≠ m·ªõi.</span>`;
      }
      const btn = document.createElement('button');
      btn.className = 'btn secondary';
      btn.dataset.wid = w.id;
      if (!w.owned) {
        const cost = 80 + idx*40;
        btn.textContent = cost + 'G M·ªü';
        btn.dataset.cost = cost;
      } else if (w.level < w.maxLevel) {
        const cost = 40 + w.level*10;
        btn.textContent = cost + 'G N√¢ng c·∫•p';
        btn.dataset.cost = cost;
      } else {
        btn.textContent = 'Max Lv';
        btn.disabled = true;
      }
      row.appendChild(meta);
      row.appendChild(btn);
      weaponShopEl.appendChild(row);
    });
  }

  document.getElementById('gunChip').addEventListener('click', () => {
    initAudio();
    // ƒë·ªïi s√∫ng
    let tries = 0;
    do {
      currentWeaponIndex = (currentWeaponIndex + 1) % weapons.length;
      tries++;
      if (tries>weapons.length) break;
    } while (!weapons[currentWeaponIndex].owned);
    updateUI();
  });

  document.getElementById('shopChip').addEventListener('click', () => {
    paused = true;
    showOverlay('shopOverlay', true);
  });

  document.getElementById('btnCloseShop').addEventListener('click', () => {
    showOverlay('shopOverlay', false);
    if (gameState === 'playing') paused = false;
  });

  // Stars->Gold buttons
  document.querySelectorAll('#shopOverlay .panel-row .btn[data-stars]')
    .forEach(btn=>{
      btn.addEventListener('click', async ()=>{
        const stars = Number(btn.dataset.stars);
        await buyGoldWithStars(stars);
      });
    });

  // Gold shop items
  document.querySelectorAll('#goldShopItems .btn[data-gitem]')
    .forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const id = btn.dataset.gitem;
        handleGoldItem(id);
      });
    });

  // Weapon shop click (event delegation)
  weaponShopEl.addEventListener('click', (e)=>{
    const btn = e.target.closest('button[data-wid]');
    if (!btn) return;
    const wid = btn.dataset.wid;
    const cost = Number(btn.dataset.cost||0);
    const w = weapons.find(x=>x.id===wid);
    if (!w) return;
    if (w.owned) {
      // upgrade
      if (w.level>=w.maxLevel) {
        showToast('V≈© kh√≠ ƒë√£ max level.');
        return;
      }
      if (gold<cost) {
        showToast('Kh√¥ng ƒë·ªß Gold ƒë·ªÉ n√¢ng c·∫•p.');
        return;
      }
      gold-=cost;
      w.level++;
      showToast(`N√¢ng ${w.name} l√™n Lv.${w.level}!`);
    } else {
      if (gold<cost) {
        showToast('Kh√¥ng ƒë·ªß Gold ƒë·ªÉ mua v≈© kh√≠.');
        return;
      }
      gold-=cost;
      w.owned=true;
      showToast(`ƒê√£ m·ªü kho√° ${w.name}!`);
    }
    updateUI();
  });

  function handleGoldItem(id) {
    if (id==='heal') {
      const cost = 20;
      if (gold<cost) return showToast('Kh√¥ng ƒë·ªß Gold ƒë·ªÉ h·ªìi m√°u.');
      gold-=cost;
      player.hp = Math.min(player.maxHp, player.hp+50);
      showToast('ƒê√£ h·ªìi +50 HP!');
    } else if (id==='armor') {
      const cost = 40;
      if (gold<cost) return showToast('Kh√¥ng ƒë·ªß Gold ƒë·ªÉ mua gi√°p.');
      gold-=cost;
      player.maxHp += 20;
      player.hp += 20;
      showToast('HP t·ªëi ƒëa +20, ƒë√£ c·ªông ngay 20 HP!');
    } else if (id==='continue') {
      const cost = 60;
      if (gold<cost) return showToast('Kh√¥ng ƒë·ªß Gold ƒë·ªÉ mua Ch∆°i ti·∫øp.');
      if (!canContinue) return showToast('Ch·ªâ d√πng ƒë∆∞·ª£c sau khi thua m√†n.');
      gold-=cost;
      player.hp = player.maxHp;
      player.alive = true;
      gameState = 'playing';
      paused = false;
      canContinue = false;
      showOverlay('menuOverlay', false);
      enemyBullets = [];
      showToast('ƒê√£ ch∆°i ti·∫øp m√†n hi·ªán t·∫°i!');
    } else if (id==='firestorm') {
      const cost = 40;
      if (gold<cost) return showToast('Kh√¥ng ƒë·ªß Gold ƒë·ªÉ mua B√£o l·ª≠a.');
      gold-=cost;
      firestormCount += 3;
      showToast('ƒê√£ mua B√£o l·ª≠a x3!');
    }
    updateUI();
  }

  async function buyGoldWithStars(starsAmount) {
    if (!tg) {
      alert('H√£y m·ªü bot trong Telegram ƒë·ªÉ thanh to√°n b·∫±ng Stars.');
      return;
    }
    try {
      const payload = 'gold-' + starsAmount + '-' + Date.now();
      const resp = await fetch(BACKEND_URL + '/api/create-invoice', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify({
          title:`Mua Gold (${starsAmount}‚≠ê)`,
          description:`ƒê·ªïi ${starsAmount} Telegram Stars l·∫•y Gold trong game`,
          price_stars: starsAmount,
          payload
        })
      });
      const j = await resp.json();
      if (!j.ok || !j.invoiceLink) {
        console.error('Create invoice error', j);
        showToast('Kh√¥ng t·∫°o ƒë∆∞·ª£c ho√° ƒë∆°n Stars.');
        return;
      }
      const invoiceLink = j.invoiceLink;
      tg.openInvoice(invoiceLink, async (status)=>{
        console.log('Stars payment status:', status);
        if (status === 'paid' || status === 'successful_payment' || status === 'ok') {
          const gained = starsAmount * GOLD_PER_STAR;
          gold += gained;
          showToast(`ƒê√£ nh·∫≠n +${gained} Gold!`);
          updateUI();
          try {
            await fetch(BACKEND_URL + '/api/deliver', {
              method:'POST',
              headers:{'Content-Type':'application/json'},
              body:JSON.stringify({ payload })
            });
          } catch(e){}
        } else {
          showToast('Thanh to√°n Stars b·ªã hu·ª∑ / l·ªói.');
        }
      });
    } catch (e) {
      console.error(e);
      showToast('L·ªói k·∫øt n·ªëi backend Stars.');
    }
  }

  // ===== MENUS / PAUSE =====
  const menuOverlay = document.getElementById('menuOverlay');
  const menuTitle = document.getElementById('menuTitle');
  const menuDesc = document.getElementById('menuDesc');
  document.getElementById('btnResume').addEventListener('click', ()=>{
    if (gameState==='playing') {
      paused = false;
      showOverlay('menuOverlay', false);
    } else if (gameState==='stageclear') {
      spawnStage(currentStage);
      gameState='playing';
      paused=false;
      showOverlay('menuOverlay', false);
    } else if (gameState==='gameover') {
      if (!canContinue) {
        paused=false;
        gameState='playing';
        showOverlay('menuOverlay', false);
      } else {
        showToast('Mua "Ch∆°i ti·∫øp" trong Shop ƒë·ªÉ ti·∫øp t·ª•c.');
      }
    }
  });
  document.getElementById('btnRestart').addEventListener('click', ()=>{
    resetGame();
    showOverlay('menuOverlay', false);
  });

  function showOverlay(id, visible) {
    const el = document.getElementById(id);
    if (!el) return;
    if (visible) el.classList.add('visible');
    else el.classList.remove('visible');
  }

  function showMenuOverlay(title, desc) {
    menuTitle.textContent = title;
    menuDesc.textContent = desc;
    showOverlay('menuOverlay', true);
  }

  const pauseBtnInner = document.getElementById('pauseBtnInner');
  pauseBtnInner.addEventListener('click', ()=>{
    if (gameState!=='playing') return;
    paused = !paused;
    if (paused) {
      showMenuOverlay('‚è∏ T·∫°m d·ª´ng', 'Game ƒëang t·∫°m d·ª´ng. Nh·∫•n "Ti·∫øp t·ª•c" ƒë·ªÉ ch∆°i ti·∫øp.');
    } else {
      showOverlay('menuOverlay', false);
    }
  });

  // B√£o l·ª≠a
  document.getElementById('fireBtn').addEventListener('click', ()=>{
    if (firestormCount<=0) {
      showToast('B·∫°n ch∆∞a c√≥ B√£o l·ª≠a. Mua trong Shop b·∫±ng Gold.');
      return;
    }
    firestormCount--;
    // Qu√©t ƒë·∫°n + tr·ª´ 10% HP qu√°i
    enemyBullets = [];
    for (const e of enemies) {
      e.hp -= e.maxHp * 0.10;
    }
    sfxExplosion();
    updateUI();
  });

  // ===== START GAME =====
  spawnStage(currentStage);
  updateUI();
</script>
</body>
</html>
