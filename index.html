<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Survival Shooter ‚Äî Stars Mini App</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />

  <!-- Telegram Mini App SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #202642 0%, #050712 55%, #020308 100%);
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    .game-wrapper {
      width: 100%;
      max-width: 420px;
      aspect-ratio: 9/16;
      border-radius: 18px;
      overflow: hidden;
      box-shadow: 0 16px 40px rgba(0,0,0,0.55);
      position: relative;
      background:#020308;
    }
    #gameCanvas {
      width: 100%;
      height: 100%;
      display: block;
      background:#020308;
    }

    .hud {
      position:absolute;
      top:8px;
      left:8px;
      right:8px;
      display:flex;
      justify-content:space-between;
      font-size:12px;
      pointer-events:none;
      text-shadow:0 1px 3px rgba(0,0,0,0.7);
    }
    .hud-section { display:flex; gap:8px; align-items:center; }

    .pill {
      background:rgba(0,0,0,0.4);
      border-radius:999px;
      padding:4px 8px;
      display:flex;
      align-items:center;
      gap:4px;
      pointer-events:auto;
    }
    .pill-label { opacity:0.7; }
    .hp-bar {
      width:80px;
      height:8px;
      border-radius:999px;
      background:rgba(255,255,255,0.1);
      overflow:hidden;
    }
    .hp-fill {
      height:100%;
      background:linear-gradient(90deg,#1be166,#9bff4f);
      width:100%;
    }

    .overlay {
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      background:linear-gradient(to top,rgba(0,0,0,0.88),rgba(0,0,0,0.65));
      text-align:center;
      padding:16px;
      z-index:5;
    }
    .overlay h1 {
      font-size:22px;
      margin-bottom:8px;
    }
    .overlay p {
      font-size:14px;
      opacity:0.9;
      margin-bottom:10px;
    }
    .overlay button {
      border:none;
      padding:10px 18px;
      border-radius:999px;
      background:#ffb100;
      color:#201317;
      font-weight:700;
      font-size:14px;
      cursor:pointer;
      margin-top:6px;
      box-shadow:0 8px 18px rgba(0,0,0,0.4);
    }
    .overlay button.secondary {
      background:rgba(255,255,255,0.08);
      color:#fff;
    }
    .overlay small {
      font-size:11px;
      opacity:0.7;
      margin-top:8px;
    }

    .shop-list {
      width:100%;
      max-width:360px;
      max-height:60%;
      overflow:auto;
      text-align:left;
      margin-top:6px;
      padding-right:2px;
    }
    .shop-item {
      background:rgba(0,0,0,0.4);
      border-radius:12px;
      padding:8px 10px;
      margin-bottom:8px;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .shop-item-header {
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:13px;
    }
    .shop-item-title { font-weight:600; }
    .shop-item-desc {
      font-size:12px;
      opacity:0.85;
    }
    .shop-item-footer {
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-top:4px;
      font-size:12px;
    }
    .shop-price {
      display:flex;
      align-items:center;
      gap:4px;
      opacity:0.9;
    }
    .shop-status-text {
      font-size:11px;
      opacity:0.75;
      margin-top:4px;
    }

    .controls {
      position:absolute;
      inset-inline:8px;
      bottom:10px;
      display:flex;
      justify-content:flex-end;
      align-items:center;
      pointer-events:none;
    }
    .ctrl-btn {
      width:54px;
      height:54px;
      border-radius:50%;
      border:none;
      background:rgba(255,255,255,0.06);
      color:#fff;
      font-size:22px;
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow:0 8px 18px rgba(0,0,0,0.6);
      backdrop-filter:blur(8px);
      -webkit-backdrop-filter:blur(8px);
      cursor:pointer;
      touch-action:none;
      pointer-events:auto;
    }
    .ctrl-btn:active { transform:scale(0.96); }

    @media (min-width: 900px) {
      .controls { display:none; }
    }
  </style>
</head>
<body>

<div class="game-wrapper">
  <canvas id="gameCanvas" width="400" height="700"></canvas>

  <div class="hud">
    <div class="hud-section">
      <div class="pill">
        <span class="pill-label">Stage</span>
        <span id="hudStage">1</span>
      </div>
      <div class="pill">
        <span class="pill-label">HP</span>
        <div class="hp-bar"><div id="hpFill" class="hp-fill"></div></div>
        <span id="hudHpText">100</span>
      </div>
    </div>
    <div class="hud-section">
      <div class="pill">
        <span class="pill-label">Weapon</span>
        <span id="hudWeapon">Pistol Lv.1</span>
      </div>
      <button class="pill" id="btnOpenShopHud" style="font-size:11px;padding:4px 10px;">
        üõí Shop
      </button>
    </div>
  </div>

  <div id="overlay" class="overlay"></div>

  <!-- Mobile: gi·ªØ n√∫t üî• l√†m skill sau n√†y -->
  <div class="controls">
    <button class="ctrl-btn" id="btnShoot">üî•</button>
  </div>
</div>

<script>
  // ===== Telegram init =====
  const tg = window.Telegram && window.Telegram.WebApp;
  function inTelegram() {
    return !!(tg && typeof tg.openInvoice === 'function');
  }
  if (tg) {
    try { tg.ready(); tg.expand(); } catch (e) {}
  }

  // ===== CONFIG =====
  const BACKEND = 'https://backend-yemh.onrender.com';
  const STORAGE_KEY = 'survival_shooter_progress_v3';
  const AUTO_SHOOT = true;

  const WEAPON_KEYS = ['pistol','rifle','shotgun','sniper'];

  const WEAPON_CONFIG = {
    pistol: {
      displayName: 'Pistol',
      levels: [
        { damage: 12, cooldown: 0.35, bulletSpeed: 500, pellets: 1 },
        { damage: 16, cooldown: 0.32, bulletSpeed: 520, pellets: 1 },
        { damage: 20, cooldown: 0.30, bulletSpeed: 540, pellets: 1 },
      ]
    },
    rifle: {
      displayName: 'Rifle',
      levels: [
        { damage: 9, cooldown: 0.18, bulletSpeed: 640, pellets: 1 },
        { damage: 12, cooldown: 0.16, bulletSpeed: 660, pellets: 1 },
        { damage: 15, cooldown: 0.14, bulletSpeed: 680, pellets: 1 },
      ]
    },
    shotgun: {
      displayName: 'Shotgun',
      levels: [
        { damage: 7, cooldown: 0.5, bulletSpeed: 460, pellets: 3 },
        { damage: 9, cooldown: 0.46, bulletSpeed: 470, pellets: 3 },
        { damage: 11, cooldown: 0.42, bulletSpeed: 480, pellets: 4 },
      ]
    },
    sniper: {
      displayName: 'Sniper',
      levels: [
        { damage: 35, cooldown: 0.9, bulletSpeed: 900, pellets: 1 },
        { damage: 45, cooldown: 0.85, bulletSpeed: 920, pellets: 1 },
        { damage: 55, cooldown: 0.8, bulletSpeed: 940, pellets: 1 },
      ]
    }
  };

  const SHOP_PRODUCTS = {
    unlock_rifle: {
      id: 'unlock_rifle',
      type: 'unlockWeapon',
      weaponKey: 'rifle',
      title: 'M·ªü kh√≥a Rifle',
      description: 'S√∫ng b·∫Øn nhanh, DPS cao h∆°n Pistol.',
      priceStars: 30
    },
    unlock_shotgun: {
      id: 'unlock_shotgun',
      type: 'unlockWeapon',
      weaponKey: 'shotgun',
      title: 'M·ªü kh√≥a Shotgun',
      description: 'B·∫Øn loe nhi·ªÅu vi√™n, d·ªçn qu√°i g·∫ßn c·ª±c t·ªët.',
      priceStars: 40
    },
    unlock_sniper: {
      id: 'unlock_sniper',
      type: 'unlockWeapon',
      weaponKey: 'sniper',
      title: 'M·ªü kh√≥a Sniper',
      description: 'S√°t th∆∞∆°ng c·ª±c cao, k·∫øt li·ªÖu boss nhanh.',
      priceStars: 50
    },
    upgrade_pistol: {
      id: 'upgrade_pistol',
      type: 'upgradeWeapon',
      weaponKey: 'pistol',
      basePrice: 15
    },
    upgrade_rifle: {
      id: 'upgrade_rifle',
      type: 'upgradeWeapon',
      weaponKey: 'rifle',
      basePrice: 18
    },
    upgrade_shotgun: {
      id: 'upgrade_shotgun',
      type: 'upgradeWeapon',
      weaponKey: 'shotgun',
      basePrice: 20
    },
    upgrade_sniper: {
      id: 'upgrade_sniper',
      type: 'upgradeWeapon',
      weaponKey: 'sniper',
      basePrice: 25
    },
    heal_full: {
      id: 'heal_full',
      type: 'heal',
      title: 'H·ªìi m√°u ƒë·∫ßy',
      description: 'H·ªìi ƒë·∫ßy HP trong tr·∫≠n hi·ªán t·∫°i.',
      priceStars: 5
    },
    armor_plus: {
      id: 'armor_plus',
      type: 'armor',
      title: 'Gi√°p vƒ©nh vi·ªÖn +20 HP',
      description: 'TƒÉng HP t·ªëi ƒëa cho t·∫•t c·∫£ tr·∫≠n sau n√†y.',
      priceStars: 12
    }
  };

  // ===== PROGRESS =====
  function loadProgress() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (e) {
      return null;
    }
  }
  function saveProgress() {
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(progress)); } catch (e) {}
  }

  const defaultProgress = {
    unlockedWeapons: { pistol: true, rifle: false, shotgun: false, sniper: false },
    weaponLevels:    { pistol: 1,    rifle: 0,     shotgun: 0,     sniper: 0     },
    armorLevel: 0,
    bestStage: 0
  };
  let progress = loadProgress() || defaultProgress;

  // ===== GAME STATE =====
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const hudStage   = document.getElementById('hudStage');
  const hpFill     = document.getElementById('hpFill');
  const hudHpText  = document.getElementById('hudHpText');
  const hudWeapon  = document.getElementById('hudWeapon');
  const btnShopHud = document.getElementById('btnOpenShopHud');
  const overlay    = document.getElementById('overlay');
  const btnShoot   = document.getElementById('btnShoot');

  const keys = { left: false, right: false, shoot: false };

  const BASE_ENEMY_HP    = 30;
  const BASE_ENEMY_DMG   = 8;
  const BASE_ENEMY_COUNT = 10;
  const ENEMY_PER_STAGE  = 5;

  let gameState = 'menu';
  let stage = 1;

  const player = {
    x: canvas.width / 2,
    y: canvas.height - 90,
    width: 60,
    height: 80,
    speed: 260,
    hp: 100,
    maxHp: 100,
    weaponKey: 'pistol',
    shotTimer: 0,
    moveDir: 0,
    shootFlashTimer: 0
  };

  let enemies = [];
  let playerBullets = [];
  let enemyBullets  = [];

  // ===== SPRITES =====
  const spritePlayer = new Image();
  spritePlayer.src = 'player.png';
  const spriteEnemy = new Image();
  spriteEnemy.src  = 'enemy_girl.png';
  const spriteBoss  = new Image();
  spriteBoss.src   = 'boss_girl.png';

  function isSpriteReady(img) {
    return img && img.complete && img.naturalWidth > 0;
  }

  // ===== AUDIO =====
  let audioCtx = null;
  let audioEnabled = true;
  function ensureAudio() {
    if (!audioEnabled) return;
    if (!audioCtx) {
      try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
      catch (e) { audioEnabled = false; }
    }
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  }
  function playTone(freq, duration, type, gainValue) {
    if (!audioEnabled || !audioCtx) return;
    const osc  = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type || 'square';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    osc.connect(gain); gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.linearRampToValueAtTime(gainValue || 0.2, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
    osc.start(now);
    osc.stop(now + duration + 0.05);
  }
  function playShotSound()      { ensureAudio(); if (!audioCtx) return; playTone(900, 0.08, 'square', 0.22); }
  function playHitSound()       { ensureAudio(); if (!audioCtx) return; playTone(500, 0.05, 'sawtooth', 0.18); }
  function playClickSound()     { ensureAudio(); if (!audioCtx) return; playTone(700, 0.04, 'triangle', 0.12); }
  function playExplosionSound() {
    ensureAudio(); if (!audioCtx) return;
    const bufferSize = audioCtx.sampleRate * 0.25;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data   = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1)*(1-i/bufferSize);
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const gain = audioCtx.createGain();
    noise.connect(gain); gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.35, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now+0.25);
    noise.start(now); noise.stop(now+0.26);
  }

  // ===== UTIL =====
  function getWeaponStats(key) {
    const cfg = WEAPON_CONFIG[key] || WEAPON_CONFIG.pistol;
    const level = Math.max(1, progress.weaponLevels[key] || 1);
    const idx = Math.min(cfg.levels.length, level) - 1;
    return cfg.levels[idx];
  }
  function updateHudWeapon() {
    const cfg = WEAPON_CONFIG[player.weaponKey];
    const lv  = progress.weaponLevels[player.weaponKey] || 1;
    hudWeapon.textContent = cfg.displayName + ' Lv.' + lv;
  }
  function resetPlayer() {
    player.x = canvas.width / 2;
    player.y = canvas.height - 90;
    player.weaponKey = 'pistol';
    player.shotTimer = 0;
    player.moveDir = 0;
    player.shootFlashTimer = 0;
    player.maxHp = 100 + progress.armorLevel * 20;
    player.hp = player.maxHp;
    updateHudWeapon();
  }

  function createStage(n) {
    enemies = [];
    playerBullets = [];
    enemyBullets  = [];

    const count = (n === 1) ? BASE_ENEMY_COUNT : BASE_ENEMY_COUNT + (n-1)*ENEMY_PER_STAGE;
    const hpMul  = Math.pow(1.2, n-1);
    const dmgMul = Math.pow(1.1, n-1);

    for (let i=0;i<count;i++) {
      enemies.push({
        x: 30 + Math.random()*(canvas.width-60),
        y: 60 + Math.random()*180,
        width: 60,
        height: 80,
        hp: BASE_ENEMY_HP*hpMul,
        maxHp: BASE_ENEMY_HP*hpMul,
        speedX: (Math.random()<0.5?-1:1)*(20+Math.random()*30),
        damage: BASE_ENEMY_DMG*dmgMul,
        shootTimer: 1 + Math.random()*2,
        type: 'normal',
        bobPhase: Math.random()*Math.PI*2,
        hitTimer: 0
      });
    }
    if (n % 2 === 0) {
      enemies.push({
        x: canvas.width/2,
        y: 80,
        width: 76,
        height: 96,
        hp: BASE_ENEMY_HP*hpMul*6,
        maxHp: BASE_ENEMY_HP*hpMul*6,
        speedX: 35,
        damage: BASE_ENEMY_DMG*dmgMul*1.5,
        shootTimer: 1.2,
        type: 'miniBoss',
        bobPhase: Math.random()*Math.PI*2,
        hitTimer: 0
      });
    }
    if (n % 10 === 0) {
      enemies.push({
        x: canvas.width/2,
        y: 95,
        width: 90,
        height: 112,
        hp: BASE_ENEMY_HP*hpMul*14,
        maxHp: BASE_ENEMY_HP*hpMul*14,
        speedX: 30,
        damage: BASE_ENEMY_DMG*dmgMul*2,
        shootTimer: 0.9,
        type: 'boss',
        bobPhase: Math.random()*Math.PI*2,
        hitTimer: 0
      });
    }
    hudStage.textContent = n;
  }

  function startGame() {
    playClickSound();
    stage = 1;
    resetPlayer();
    createStage(stage);
    gameState = 'playing';
    hideOverlay();
  }
  function nextStage() {
    playClickSound();
    stage += 1;
    if (stage > progress.bestStage) { progress.bestStage = stage; saveProgress(); }
    player.hp = Math.min(player.hp + 30, player.maxHp);
    createStage(stage);
    gameState = 'playing';
    hideOverlay();
  }

  // ===== OVERLAY =====
  function showMainMenu() {
    gameState = 'menu';
    overlay.innerHTML = `
      <h1>üéÆ Survival Shooter</h1>
      <p>Vu·ªët/ng√≥n tay ƒë·ªÉ di chuy·ªÉn, auto-b·∫Øn h·∫° qu√°i ƒë·ªÉ v∆∞·ª£t ·∫£i.<br/>
      D√πng <b>Stars Telegram</b> ƒë·ªÉ m·ªü kh√≥a & n√¢ng c·∫•p v≈© kh√≠.</p>
      <p style="font-size:13px;opacity:0.9">
        <b>PC:</b> A/D di chuy·ªÉn (auto b·∫Øn).<br/>
        <b>ƒêi·ªán tho·∫°i:</b> Vu·ªët ƒë·ªÉ di chuy·ªÉn, n√∫t üî• s·∫Ω d√πng l√†m skill sau n√†y.
      </p>
      <button id="btnStartGame">B·∫Øt ƒë·∫ßu ·∫£i 1</button>
      <button id="btnOpenShopFromMenu" class="secondary">üõí M·ªü Shop (Stars)</button>
      <small>Ti·∫øn tr√¨nh v≈© kh√≠ ƒë∆∞·ª£c l∆∞u tr√™n thi·∫øt b·ªã n√†y.</small>
    `;
    overlay.style.display = 'flex';
    document.getElementById('btnStartGame').onclick = () => { ensureAudio(); startGame(); };
    document.getElementById('btnOpenShopFromMenu').onclick = () => { ensureAudio(); showShop(); };
  }
  function showStageClear() {
    overlay.innerHTML = `
      <h1>‚úÖ Ho√†n th√†nh ·∫£i ${stage}</h1>
      <p>B·∫°n ƒë√£ s·ªëng s√≥t qua ·∫£i <b>${stage}</b>! Qu√°i ·∫£i sau s·∫Ω ƒë√¥ng & tr√¢u h∆°n.</p>
      <button id="btnNextStage">Ti·∫øp t·ª•c ·∫£i ${stage+1}</button>
      <button id="btnOpenShopFromStage" class="secondary">üõí M·ªü Shop (Stars)</button>
    `;
    overlay.style.display = 'flex';
    document.getElementById('btnNextStage').onclick = () => { ensureAudio(); nextStage(); };
    document.getElementById('btnOpenShopFromStage').onclick = () => { ensureAudio(); showShop(); };
  }
  function showGameOver() {
    overlay.innerHTML = `
      <h1>üíÄ Game Over</h1>
      <p>B·∫°n d·ª´ng l·∫°i ·ªü ·∫£i <b>${stage}</b>. H√£y n√¢ng c·∫•p v≈© kh√≠ b·∫±ng Stars ƒë·ªÉ ƒëi xa h∆°n!</p>
      <button id="btnRetry">Ch∆°i l·∫°i t·ª´ ·∫£i 1</button>
      <button id="btnOpenShopFromOver" class="secondary">üõí M·ªü Shop (Stars)</button>
    `;
    overlay.style.display = 'flex';
    document.getElementById('btnRetry').onclick = () => { ensureAudio(); startGame(); };
    document.getElementById('btnOpenShopFromOver').onclick = () => { ensureAudio(); showShop(); };
  }
  function hideOverlay() { overlay.style.display = 'none'; }

  // ===== SHOP =====
  function getUpgradePrice(product) {
    const lvl = progress.weaponLevels[product.weaponKey] || 1;
    if (lvl >= 3) return null;
    return product.basePrice * lvl;
  }
  function getProductPrice(id) {
    const p = SHOP_PRODUCTS[id]; if (!p) return null;
    if (p.type === 'upgradeWeapon') return getUpgradePrice(p);
    return p.priceStars;
  }
  function getProductStateText(p) {
    if (p.type === 'unlockWeapon') {
      const unlocked = !!progress.unlockedWeapons[p.weaponKey];
      return unlocked ? 'ƒê√£ m·ªü kh√≥a' : 'Ch∆∞a s·ªü h·ªØu';
    }
    if (p.type === 'upgradeWeapon') {
      const lvl = progress.weaponLevels[p.weaponKey] || 1;
      if (!progress.unlockedWeapons[p.weaponKey]) return 'Ch∆∞a m·ªü kh√≥a v≈© kh√≠ n√†y';
      if (lvl >= 3) return `ƒê√£ t·ªëi ƒëa (Lv.${lvl})`;
      return `Hi·ªán t·∫°i: Lv.${lvl}`;
    }
    if (p.type === 'heal')   return 'H·ªìi m√°u trong tr·∫≠n hi·ªán t·∫°i';
    if (p.type === 'armor')  return `Gi√°p hi·ªán t·∫°i: +${progress.armorLevel*20} HP`;
    return '';
  }
  function isProductBuyable(p) {
    if (p.type === 'unlockWeapon' && progress.unlockedWeapons[p.weaponKey]) return false;
    if (p.type === 'upgradeWeapon') {
      if (!progress.unlockedWeapons[p.weaponKey]) return false;
      const lvl = progress.weaponLevels[p.weaponKey] || 1;
      if (lvl >= 3) return false;
      return true;
    }
    if (p.type === 'heal') {
      if (gameState !== 'playing') return false;
      if (player.hp >= player.maxHp) return false;
      return true;
    }
    if (p.type === 'armor') return true;
    return true;
  }

  function showShop(message) {
    const msg = message || 'Mua v≈© kh√≠ v√† item b·∫±ng Stars Telegram.';
    const rows = [];
    Object.values(SHOP_PRODUCTS).forEach(p => {
      const price = getProductPrice(p.id);
      const stateText = getProductStateText(p);
      const buyable = isProductBuyable(p) && price !== null;
      let priceText = price !== null ? `${price} ‚≠ê` : '‚Äî';
      if (p.type === 'upgradeWeapon' && price !== null) {
        const lvl = progress.weaponLevels[p.weaponKey] || 1;
        priceText = `${price} ‚≠ê (n√¢ng l√™n Lv.${lvl+1})`;
      }
      rows.push(`
        <div class="shop-item">
          <div class="shop-item-header">
            <span class="shop-item-title">${p.title || ('Item '+p.id)}</span>
            <span style="font-size:11px;opacity:0.8;">${p.type}</span>
          </div>
          <div class="shop-item-desc">${p.description || ''}</div>
          <div class="shop-item-footer">
            <div class="shop-price">
              <span>Gi√°:</span>
              <b>${priceText}</b>
            </div>
            <button
              class="secondary"
              data-product-id="${p.id}"
              ${buyable ? '' : 'disabled style="opacity:0.5;cursor:not-allowed;"'}
              style="padding:6px 10px;border-radius:999px;font-size:12px;">
              ${buyable ? 'Mua b·∫±ng Stars' : 'Kh√¥ng th·ªÉ mua'}
            </button>
          </div>
          <div class="shop-status-text">${stateText}</div>
        </div>
      `);
    });

    overlay.innerHTML = `
      <h1>üõí Shop (Stars)</h1>
      <p>${msg}</p>
      <div class="shop-list">${rows.join('')}</div>
      <button id="btnBackFromShop" class="secondary">‚¨Ö Quay l·∫°i</button>
      <small id="shopStatusText" style="margin-top:4px;">Tip: H√£y test v·ªõi s·ªë Stars nh·ªè tr∆∞·ªõc.</small>
    `;
    overlay.style.display = 'flex';

    document.getElementById('btnBackFromShop').onclick = () => {
      playClickSound();
      if (gameState === 'playing') hideOverlay();
      else if (gameState === 'gameOver') showGameOver();
      else if (gameState === 'stageClear') showStageClear();
      else showMainMenu();
    };

    document.querySelectorAll('.shop-item button[data-product-id]').forEach(btn => {
      btn.onclick = () => {
        const id = btn.getAttribute('data-product-id');
        ensureAudio(); playClickSound(); startPurchase(id);
      };
    });
  }

  function setShopStatus(text, isError) {
    const el = document.getElementById('shopStatusText');
    if (!el) return;
    el.textContent = text;
    el.style.color = isError ? '#ff8080' : '#ffffff';
  }

  async function createInvoice(productId, priceStars, payload) {
    const p = SHOP_PRODUCTS[productId];
    const title = p.title || 'Item '+productId;
    const description = p.description || 'Mua v·∫≠t ph·∫©m trong game b·∫±ng Telegram Stars.';
    const r = await fetch(BACKEND + '/api/create-invoice', {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({ title, description, price_stars: priceStars, payload })
    });
    return r.json();
  }
  async function deliverReward(payload) {
    try {
      const r = await fetch(BACKEND + '/api/deliver', {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ payload })
      });
      return r.json();
    } catch (e) { return { ok:false, error:e.message }; }
  }

  function applyPurchase(productId) {
    const p = SHOP_PRODUCTS[productId]; if (!p) return;
    if (p.type === 'unlockWeapon') {
      progress.unlockedWeapons[p.weaponKey] = true;
      if (!progress.weaponLevels[p.weaponKey] || progress.weaponLevels[p.weaponKey]<=0) {
        progress.weaponLevels[p.weaponKey] = 1;
      }
      saveProgress(); updateHudWeapon();
      showShop('Mua th√†nh c√¥ng! V≈© kh√≠ m·ªõi ƒë√£ ƒë∆∞·ª£c m·ªü kh√≥a.');
      return;
    }
    if (p.type === 'upgradeWeapon') {
      if (!progress.unlockedWeapons[p.weaponKey]) { showShop('Ch∆∞a m·ªü kh√≥a v≈© kh√≠ n√†y.'); return; }
      const lvl = progress.weaponLevels[p.weaponKey] || 1;
      if (lvl >= 3) { showShop('V≈© kh√≠ n√†y ƒë√£ t·ªëi ƒëa.'); return; }
      progress.weaponLevels[p.weaponKey] = lvl+1; saveProgress();
      if (player.weaponKey === p.weaponKey) updateHudWeapon();
      showShop('N√¢ng c·∫•p th√†nh c√¥ng! V≈© kh√≠ m·∫°nh h∆°n r·ªìi.');
      return;
    }
    if (p.type === 'heal') {
      player.hp = player.maxHp;
      showShop('ƒê√£ h·ªìi ƒë·∫ßy m√°u cho tr·∫≠n hi·ªán t·∫°i.');
      return;
    }
    if (p.type === 'armor') {
      progress.armorLevel += 1; saveProgress();
      showShop('ƒê√£ tƒÉng gi√°p vƒ©nh vi·ªÖn. T·ª´ tr·∫≠n sau b·∫°n s·∫Ω c√≥ nhi·ªÅu HP h∆°n.');
      return;
    }
  }

  async function startPurchase(productId) {
    const p = SHOP_PRODUCTS[productId]; if (!p) return;
    if (!inTelegram()) { alert('B·∫°n ch·ªâ c√≥ th·ªÉ mua b·∫±ng Stars khi m·ªü game trong Telegram.'); return; }
    const price = getProductPrice(productId);
    if (price == null) { showShop('M·ª•c n√†y hi·ªán kh√¥ng th·ªÉ mua.'); return; }
    if (!isProductBuyable(p)) { showShop('M·ª•c n√†y hi·ªán kh√¥ng th·ªÉ mua ·ªü tr·∫°ng th√°i hi·ªán t·∫°i.'); return; }

    try {
      setShopStatus('ƒêang t·∫°o ho√° ƒë∆°n Stars...', false);
      const payload = 'game-'+productId+'-'+Date.now();
      const j = await createInvoice(productId, price, payload);
      if (!j.ok || !j.invoiceLink) {
        setShopStatus('Kh√¥ng t·∫°o ƒë∆∞·ª£c invoice: '+(j.error||'unknown'), true); return;
      }
      const link = j.invoiceLink;
      tg.openInvoice(link, async (status) => {
        const st = typeof status === 'string' ? status : status && status.status;
        console.log('openInvoice shop status =', st);
        if (st === 'paid') {
          setShopStatus('Thanh to√°n th√†nh c√¥ng, ƒëang c·∫•p v·∫≠t ph·∫©m...', false);
          try { await deliverReward(payload); } catch(e){}
          applyPurchase(productId);
        } else if (st === 'cancelled') {
          setShopStatus('B·∫°n ƒë√£ ƒë√≥ng c·ª≠a s·ªï thanh to√°n.', true);
        } else if (st === 'failed') {
          setShopStatus('Telegram b√°o l·ªói thanh to√°n (failed).', true);
        } else {
          setShopStatus('Thanh to√°n kh√¥ng th√†nh c√¥ng, tr·∫°ng th√°i: '+st, true);
        }
      });
    } catch (e) {
      console.error(e);
      setShopStatus('L·ªói khi t·∫°o/m·ªü invoice: '+e.message, true);
    }
  }

  btnShopHud.addEventListener('click', () => { ensureAudio(); playClickSound(); showShop(); });

  // ===== INPUT: KEYBOARD (PC) =====
  window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;

    if (e.code === 'KeyQ') {
      let idx = WEAPON_KEYS.indexOf(player.weaponKey);
      for (let i=1;i<=WEAPON_KEYS.length;i++) {
        const nextKey = WEAPON_KEYS[(idx+i)%WEAPON_KEYS.length];
        if (progress.unlockedWeapons[nextKey]) { player.weaponKey = nextKey; break; }
      }
      updateHudWeapon();
    }
    if (gameState==='menu' && e.code==='Enter') { ensureAudio(); startGame(); }
    else if (gameState==='stageClear' && e.code==='Enter') { ensureAudio(); nextStage(); }
    else if (gameState==='gameOver' && e.code==='Enter') { ensureAudio(); startGame(); }
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
  });

  // ===== INPUT: TOUCH / DRAG =====
  let isDragging = false;
  function pointerToCanvasX(ev) {
    const rect = canvas.getBoundingClientRect();
    return (ev.clientX - rect.left) * (canvas.width / rect.width);
  }

  canvas.addEventListener('pointerdown', (ev) => {
    ensureAudio();
    isDragging = true;
    const x = pointerToCanvasX(ev);
    const clamped = Math.max(player.width/2+10, Math.min(canvas.width-player.width/2-10, x));
    const dir = Math.sign(clamped - player.x);
    if (dir !== 0) player.moveDir = dir;
    player.x = clamped;
  });
  canvas.addEventListener('pointermove', (ev) => {
    if (!isDragging) return;
    const x = pointerToCanvasX(ev);
    const clamped = Math.max(player.width/2+10, Math.min(canvas.width-player.width/2-10, x));
    const dir = Math.sign(clamped - player.x);
    if (dir !== 0) player.moveDir = dir;
    player.x = clamped;
  });
  canvas.addEventListener('pointerup',   () => { isDragging = false; });
  canvas.addEventListener('pointerleave',() => { isDragging = false; });

  // n√∫t üî• t·∫°m cho n·ªï vui tai (sau d√πng l√†m skill)
  function bindTouchHold(el, onChange) {
    const s = (ev)=>{ev.preventDefault();onChange(true);};
    const e = (ev)=>{ev.preventDefault();onChange(false);};
    el.addEventListener('touchstart', s);
    el.addEventListener('touchend', e);
    el.addEventListener('touchcancel', e);
    el.addEventListener('mousedown', s);
    el.addEventListener('mouseup', e);
    el.addEventListener('mouseleave', e);
  }
  bindTouchHold(btnShoot, (v)=>{ if (v){ ensureAudio(); playExplosionSound(); } });

  // ===== GAME UPDATE =====
  function updatePlayer(dt) {
    let dir = 0;
    if (keys.left && !keys.right) dir = -1;
    else if (keys.right && !keys.left) dir = 1;

    if (dir !== 0) {
      player.moveDir = dir;
    } else {
      player.moveDir *= 0.9;
      if (Math.abs(player.moveDir) < 0.01) player.moveDir = 0;
    }

    if (dir === -1) player.x -= player.speed * dt;
    if (dir === 1)  player.x += player.speed * dt;

    player.x = Math.max(player.width/2+10, Math.min(canvas.width-player.width/2-10, player.x));

    const stats = getWeaponStats(player.weaponKey);
    updateHudWeapon();

    if (player.shotTimer > 0) player.shotTimer -= dt;

    const wantShoot = AUTO_SHOOT || keys.shoot;
    if (wantShoot && player.shotTimer <= 0) {
      player.shotTimer = stats.cooldown;
      const originY = player.y - player.height/2 + 10;
      const originX = player.x;
      const pellets = stats.pellets || 1;
      for (let i=0;i<pellets;i++) {
        const spread = (pellets===1)?0:(i-(pellets-1)/2)*18;
        playerBullets.push({
          x: originX + spread,
          y: originY,
          radius: 4,
          vy: -stats.bulletSpeed,
          damage: stats.damage
        });
      }
      player.shootFlashTimer = 0.08;
      playShotSound();
    }
    if (player.shootFlashTimer > 0) {
      player.shootFlashTimer -= dt;
      if (player.shootFlashTimer < 0) player.shootFlashTimer = 0;
    }
  }

  function updateEnemies(dt) {
    for (let i=enemies.length-1;i>=0;i--) {
      const e = enemies[i];
      e.x += e.speedX * dt;
      if (e.x < e.width/2 + 10) { e.x = e.width/2 + 10; e.speedX *= -1; }
      else if (e.x > canvas.width - e.width/2 - 10) { e.x = canvas.width - e.width/2 - 10; e.speedX *= -1; }

      e.shootTimer -= dt;
      if (e.shootTimer <= 0) {
        e.shootTimer = (e.type==='normal') ? (1.3+Math.random()*1.7) : (0.7+Math.random()*1.0);
        enemyBullets.push({
          x:e.x,
          y:e.y + e.height/2 - 10,
          radius:4,
          vy: 200 + (e.type==='boss'?80:0),
          damage:e.damage
        });
      }
      if (e.hitTimer > 0) e.hitTimer -= dt;
    }
  }

  function updateBullets(dt) {
    for (let i=playerBullets.length-1;i>=0;i--) {
      const b = playerBullets[i];
      b.y += b.vy * dt;
      if (b.y < -20) playerBullets.splice(i,1);
    }
    for (let i=enemyBullets.length-1;i>=0;i--) {
      const b = enemyBullets[i];
      b.y += b.vy * dt;
      if (b.y > canvas.height+20) enemyBullets.splice(i,1);
    }
  }

  function rectCircleColliding(circle, rect) {
    const distX = Math.abs(circle.x - rect.x);
    const distY = Math.abs(circle.y - rect.y);
    if (distX > (rect.width/2 + circle.radius)) return false;
    if (distY > (rect.height/2 + circle.radius)) return false;
    if (distX <= (rect.width/2)) return true;
    if (distY <= (rect.height/2)) return true;
    const dx = distX - rect.width/2;
    const dy = distY - rect.height/2;
    return (dx*dx + dy*dy <= circle.radius*circle.radius);
  }

  function handleCollisions() {
    for (let i=playerBullets.length-1;i>=0;i--) {
      const b = playerBullets[i];
      let hit = false;
      for (let j=enemies.length-1;j>=0;j--) {
        const e = enemies[j];
        if (rectCircleColliding(b, e)) {
          e.hp -= b.damage;
          e.hitTimer = 0.12;
          hit = true;
          playHitSound();
          if (e.hp <= 0) {
            enemies.splice(j,1);
            playExplosionSound();
          }
          break;
        }
      }
      if (hit) playerBullets.splice(i,1);
    }

    for (let i=enemyBullets.length-1;i>=0;i--) {
      const b = enemyBullets[i];
      if (rectCircleColliding(b, player)) {
        enemyBullets.splice(i,1);
        player.hp -= b.damage;
        playHitSound();
        if (player.hp <= 0) {
          player.hp = 0; playExplosionSound(); onGameOver(); return;
        }
      }
    }

    for (let i=enemies.length-1;i>=0;i--) {
      const e = enemies[i];
      const circ = { x:e.x, y:e.y, radius:Math.max(e.width,e.height)/2 };
      if (rectCircleColliding(circ, player)) {
        player.hp -= e.damage*0.7;
        e.hitTimer = 0.12;
        enemies.splice(i,1);
        playHitSound();
        if (player.hp <= 0) {
          player.hp = 0; playExplosionSound(); onGameOver(); return;
        }
      }
    }

    if (enemies.length===0 && gameState==='playing') onStageClear();
  }

  function onStageClear() {
    if (stage > progress.bestStage) { progress.bestStage = stage; saveProgress(); }
    gameState = 'stageClear'; showStageClear();
  }
  function onGameOver() {
    if (stage > progress.bestStage) { progress.bestStage = stage; saveProgress(); }
    gameState = 'gameOver'; showGameOver();
  }

  // ===== BACKGROUND: SKY SCROLL =====
  const STAR_COUNT = 60;
  const stars = [];
  function initStars() {
    stars.length = 0;
    for (let i=0;i<STAR_COUNT;i++) {
      stars.push({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        speed: 25 + Math.random()*40,
        size: 1 + Math.random()*1.5,
        alpha: 0.25 + Math.random()*0.5
      });
    }
  }

  function updateStars(dt) {
    for (const s of stars) {
      s.y += s.speed * dt;
      if (s.y > canvas.height) s.y -= canvas.height;
    }
  }

  function drawBackground() {
    const grd = ctx.createLinearGradient(0,0,0,canvas.height);
    grd.addColorStop(0, '#141b3a');
    grd.addColorStop(0.4,'#050a18');
    grd.addColorStop(1, '#020309');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.save();
    ctx.fillStyle = '#ffffff';
    for (const s of stars) {
      ctx.globalAlpha = s.alpha;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // ===== RENDER =====
  let globalTime = 0;

  function drawPlayer() {
    const w = player.width;
    const h = player.height;
    const t = globalTime;

    const bob  = Math.sin(t*4)*3;
    const tilt = player.moveDir * 0.25;

    ctx.save();
    ctx.translate(player.x, player.y + bob);
    ctx.rotate(tilt);

    if (isSpriteReady(spritePlayer)) {
      ctx.drawImage(spritePlayer, -w/2, -h/2, w, h);
    } else {
      ctx.fillStyle = '#66ff99';
      ctx.fillRect(-w/2, -h/2, w, h);
    }

    if (player.shootFlashTimer > 0) {
      const k = player.shootFlashTimer / 0.08;
      ctx.save();
      ctx.translate(w/2 - 10, -h/2 + 20);
      ctx.rotate(0.2);
      const len = 26 * k;
      const wid = 8  * k;
      const grd = ctx.createLinearGradient(0,-wid, len,wid);
      grd.addColorStop(0,'rgba(0,255,255,0.9)');
      grd.addColorStop(1,'rgba(0,255,255,0)');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.moveTo(0, -wid);
      ctx.lineTo(len, 0);
      ctx.lineTo(0, wid);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    ctx.restore();
  }

  function spriteForEnemy(e) { return (e.type==='boss'||e.type==='miniBoss') ? spriteBoss : spriteEnemy; }

  function drawEnemies() {
    const t = globalTime;
    enemies.forEach(e => {
      const w = e.width;
      const h = e.height;

      const baseBob = (e.type==='boss') ? 5 : 3;
      const bob  = Math.sin(t*3 + e.bobPhase) * baseBob;
      const tilt = Math.sin(t*2 + e.bobPhase*1.3) * 0.1;

      let scale = 1;
      if (e.type === 'boss')  scale = 1 + Math.sin(t*1.5 + e.bobPhase)*0.03;
      if (e.hitTimer > 0)     scale *= 1.06;

      ctx.save();
      ctx.translate(e.x, e.y + bob);
      ctx.rotate(tilt);
      ctx.scale(scale, scale);

      const spr = spriteForEnemy(e);
      if (isSpriteReady(spr)) {
        ctx.drawImage(spr, -w/2, -h/2, w, h);
      } else {
        ctx.fillStyle = e.type==='boss' ? '#ff4b5c' : (e.type==='miniBoss' ? '#ff9f43' : '#4af0ff');
        ctx.fillRect(-w/2, -h/2, w, h);
      }

      ctx.restore();

      const barW = w;
      const barH = 4;
      const pct = e.hp / e.maxHp;
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(e.x - barW/2, e.y - h/2 - 6, barW, barH);
      ctx.fillStyle = '#3cf06f';
      ctx.fillRect(e.x - barW/2, e.y - h/2 - 6, barW*pct, barH);
    });
  }

  function drawBullets() {
    ctx.fillStyle = '#ffeb3b';
    playerBullets.forEach(b => {
      ctx.beginPath(); ctx.arc(b.x,b.y,b.radius,0,Math.PI*2); ctx.fill();
    });
    ctx.fillStyle = '#ff5252';
    enemyBullets.forEach(b => {
      ctx.beginPath(); ctx.arc(b.x,b.y,b.radius,0,Math.PI*2); ctx.fill();
    });
  }

  function updateHud() {
    const hpPct = Math.max(0, Math.min(1, player.hp / player.maxHp));
    hpFill.style.width = (hpPct*100)+'%';
    hudHpText.textContent = Math.round(player.hp);
  }

  function drawFrame(dt) {
    drawBackground();
    drawPlayer();
    drawEnemies();
    drawBullets();
    updateHud();
  }

  // ===== LOOP =====
  let lastTime = 0;
  function loop(ts) {
    const dt = Math.min(0.033,(ts-lastTime)/1000 || 0);
    lastTime = ts;
    globalTime = ts/1000;

    updateStars(dt);

    if (gameState === 'playing') {
      updatePlayer(dt);
      updateEnemies(dt);
      updateBullets(dt);
      handleCollisions();
    }

    drawFrame(dt);
    requestAnimationFrame(loop);
  }

  // ===== INIT =====
  resetPlayer();
  initStars();
  showMainMenu();
  requestAnimationFrame(loop);
</script>

</body>
</html>
