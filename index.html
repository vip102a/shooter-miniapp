<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Survival Shooter ‚Äî Stars + Gold Mini App</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />

  <!-- Telegram Mini App SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #202642 0%, #050712 55%, #020308 100%);
      color: #fff;
      width: 100%;
      height: 100vh;
      overflow: hidden;
    }

    .game-wrapper {
      position: fixed;
      inset: 0;              /* top:0; right:0; bottom:0; left:0 */
      width: 100%;
      height: 100vh;         /* chi·∫øm to√†n b·ªô khung mini app */
      max-width: none;
      border-radius: 0;
      overflow: hidden;
      background:#020308;
    }

    #gameCanvas {
      width: 100%;
      height: 100%;
      display: block;
      background:#020308;
    }

    /* ===== HUD ===== */
    .hud {
      position:absolute;
      top:8px;
      left:8px;
      right:8px;
      display:flex;
      flex-direction:column;
      gap:4px;
      font-size:12px;
      pointer-events:none;
      text-shadow:0 1px 3px rgba(0,0,0,0.7);
    }
    .hud-top {
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:4px;
    }
    .hud-left, .hud-center, .hud-right {
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .hud-row {
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:nowrap;
    }
    .hud-right-row {
      justify-content:flex-end;
    }
    @media (max-width: 480px) {
      .hud-right-row {
        flex-wrap:wrap;
        justify-content:flex-end;
      }
    }
    .hud-bottom {
      display:flex;
      align-items:flex-start;
    }

    .pill {
      background:rgba(0,0,0,0.4);
      border-radius:999px;
      padding:4px 8px;
      display:flex;
      align-items:center;
      gap:4px;
      pointer-events:auto;
      border:none;
      color:#fff;
      font-size:12px;
    }
    .pill-label { opacity:0.7; }

    /* HP bar */
    .hp-bar {
      width:80px;
      height:8px;
      border-radius:999px;
      background:rgba(255,255,255,0.1);
      overflow:hidden;
    }
    .hp-fill {
      height:100%;
      background:linear-gradient(90deg,#1be166,#9bff4f);
      width:100%;
    }

    /* Gold pill: 2 d√≤ng */
    .pill-gold {
      flex-direction:column;
      align-items:center;
      min-width:64px;
      padding-inline:10px;
    }
    .pill-gold .pill-label {
      font-size:11px;
    }
    .pill-gold .pill-value {
      font-size:13px;
      font-weight:600;
    }

    /* Weapon pill g·ªôp */
    .pill-weapon {
      flex-direction:column;
      align-items:flex-start;
      min-width:90px;
      padding-inline:10px;
      cursor:pointer;
    }
    .weapon-top {
      display:flex;
      align-items:center;
      gap:4px;
      font-size:12px;
    }
    .weapon-icon {
      font-size:13px;
    }
    .weapon-bottom {
      font-size:11px;
      opacity:0.85;
      margin-top:1px;
    }

    .overlay {
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      background:linear-gradient(to top,rgba(0,0,0,0.88),rgba(0,0,0,0.65));
      text-align:center;
      padding:16px;
      z-index:5;
    }
    .overlay h1 {
      font-size:22px;
      margin-bottom:8px;
    }
    .overlay p {
      font-size:14px;
      opacity:0.9;
      margin-bottom:10px;
    }
    .overlay button {
      border:none;
      padding:10px 18px;
      border-radius:999px;
      background:#ffb100;
      color:#201317;
      font-weight:700;
      font-size:14px;
      cursor:pointer;
      margin-top:6px;
      box-shadow:0 8px 18px rgba(0,0,0,0.4);
    }
    .overlay button.secondary {
      background:rgba(255,255,255,0.08);
      color:#fff;
    }
    .overlay small {
      font-size:11px;
      opacity:0.7;
      margin-top:8px;
    }

    .shop-tabs {
      display:flex;
      gap:8px;
      margin-bottom:8px;
      width:100%;
      max-width:360px;
    }
    .shop-tab {
      flex:1;
      border:none;
      border-radius:999px;
      padding:6px 8px;
      font-size:12px;
      cursor:pointer;
      background:rgba(255,255,255,0.08);
      color:#fff;
    }
    .shop-tab.active {
      background:#ffb100;
      color:#201317;
      font-weight:700;
    }

    .shop-list {
      width:100%;
      max-width:360px;
      max-height:55%;
      overflow:auto;
      text-align:left;
      margin-top:6px;
      padding-right:2px;
    }
    .shop-item {
      background:rgba(0,0,0,0.4);
      border-radius:12px;
      padding:8px 10px;
      margin-bottom:8px;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .shop-item-header {
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:13px;
    }
    .shop-item-title { font-weight:600; }
    .shop-item-desc {
      font-size:12px;
      opacity:0.85;
    }
    .shop-item-footer {
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-top:4px;
      font-size:12px;
    }
    .shop-price {
      display:flex;
      align-items:center;
      gap:4px;
      opacity:0.9;
    }
    .shop-status-text {
      font-size:11px;
      opacity:0.75;
      margin-top:4px;
    }

    .controls {
      position:absolute;
      inset-inline:8px;
      bottom:10px;
      display:flex;
      justify-content:flex-end;
      align-items:center;
      pointer-events:none;
    }
    .ctrl-btn {
      width:54px;
      height:54px;
      border-radius:50%;
      border:none;
      background:rgba(255,255,255,0.06);
      color:#fff;
      font-size:18px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      line-height:1.1;
      box-shadow:0 8px 18px rgba(0,0,0,0.6);
      backdrop-filter:blur(8px);
      -webkit-backdrop-filter:blur(8px);
      cursor:pointer;
      touch-action:none;
      pointer-events:auto;
    }
    .ctrl-btn span {
      font-size:11px;
      opacity:0.9;
    }
    .ctrl-btn:active { transform:scale(0.96); }

    @media (min-width: 900px) {
      .controls { display:none; }
    }
  </style>
</head>
<body>

<div class="game-wrapper">
  <canvas id="gameCanvas" width="400" height="700"></canvas>

  <!-- HUD -->
  <div class="hud">
    <div class="hud-top">
      <!-- Tr√°i: Stage -->
      <div class="hud-left">
        <div class="hud-row">
          <div class="pill">
            <span class="pill-label">Stage</span>
            <span id="hudStage">1</span>
          </div>
        </div>
      </div>

      <!-- Gi·ªØa: HP -->
      <div class="hud-center">
        <div class="hud-row">
          <div class="pill">
            <span class="pill-label">HP</span>
            <div class="hp-bar"><div id="hpFill" class="hp-fill"></div></div>
            <span id="hudHpText">100</span>
          </div>
        </div>
      </div>

      <!-- Ph·∫£i: Gold + Weapon + Shop -->
      <div class="hud-right">
        <div class="hud-row hud-right-row">
          <!-- Gold 2 d√≤ng -->
          <div class="pill pill-gold">
            <span class="pill-label">Gold</span>
            <span class="pill-value" id="hudGold">0</span>
          </div>

          <!-- Weapon: icon + name + Lv -->
          <button class="pill pill-weapon" id="btnWeapon">
            <div class="weapon-top">
              <span class="weapon-icon">üîÅ</span>
              <span id="hudWeaponName">Pistol</span>
            </div>
            <div class="weapon-bottom" id="hudWeaponLevel">Lv.1</div>
          </button>

          <!-- Shop -->
          <button class="pill" id="btnOpenShopHud" style="font-size:11px;padding:4px 10px;">
            üõí Shop
          </button>
        </div>
      </div>
    </div>

    <!-- D∆∞·ªõi: ch·ªâ c√≥ Pause, d∆∞·ªõi c·ªôt Stage -->
    <div class="hud-bottom">
      <button class="pill" id="btnPauseHud">‚è∏ T·∫°m d·ª´ng</button>
    </div>
  </div>

  <div id="overlay" class="overlay"></div>

  <!-- B√£o l·ª≠a -->
  <div class="controls">
    <button class="ctrl-btn" id="btnShoot">
      üî•
      <span id="firestormCountLabel">x0</span>
    </button>
  </div>
</div>

<script>
  // ===== Telegram init =====
  const tg = window.Telegram && window.Telegram.WebApp;
  function inTelegram() {
    return !!(tg && typeof tg.openInvoice === 'function');
  }
  if (tg) {
    try { tg.ready(); tg.expand(); } catch (e) {}
  }

  // ===== CONFIG =====
  const BACKEND     = 'https://backend-yemh.onrender.com';
  const STORAGE_KEY = 'survival_shooter_progress_v5';

  // Production: d√πng Stars th·∫≠t
  const DEV_FREE_STARS = false;

  const AUTO_SHOOT = true;
  const WEAPON_KEYS = ['pistol','rifle','shotgun','sniper'];

  const WEAPON_CONFIG = {
    pistol: { displayName: 'Pistol',  levels: [] },
    rifle:  { displayName: 'Rifle',   levels: [] },
    shotgun:{ displayName: 'Shotgun', levels: [] },
    sniper: { displayName: 'Sniper',  levels: [] }
  };

  // ===== WEAPON LEVELS INIT =====
  (function initWeapons() {
    // Pistol: 3 level
    WEAPON_CONFIG.pistol.levels = [
      { damage: 12, cooldown: 0.35, bulletSpeed: 500, pellets: 1 },
      { damage: 16, cooldown: 0.32, bulletSpeed: 520, pellets: 1 },
      { damage: 20, cooldown: 0.30, bulletSpeed: 540, pellets: 1 },
    ];
    // Rifle: 3 level
    WEAPON_CONFIG.rifle.levels = [
      { damage: 9, cooldown: 0.18, bulletSpeed: 640, pellets: 1 },
      { damage: 12, cooldown: 0.16, bulletSpeed: 660, pellets: 1 },
      { damage: 15, cooldown: 0.14, bulletSpeed: 680, pellets: 1 },
    ];
    // Shotgun: 3 level
    WEAPON_CONFIG.shotgun.levels = [
      { damage: 7, cooldown: 0.5,  bulletSpeed: 460, pellets: 3 },
      { damage: 9, cooldown: 0.46, bulletSpeed: 470, pellets: 3 },
      { damage: 11,cooldown: 0.42, bulletSpeed: 480, pellets: 4 },
    ];
    // Sniper: 20 level, l·∫ª tƒÉng dame, ch·∫µn tƒÉng t·ªëc b·∫Øn
    const levels = [];
    let dmg = 40;
    let cd  = 1.1;
    let spd = 900;
    for (let lv = 1; lv <= 20; lv++) {
      levels.push({ damage: dmg, cooldown: cd, bulletSpeed: spd, pellets: 1 });
      if (lv % 2 === 1) {
        dmg += 6;
      } else {
        cd  = Math.max(0.25, cd * 0.92);
        spd += 10;
      }
    }
    WEAPON_CONFIG.sniper.levels = levels;
  })();

  function getMaxWeaponLevel(key) {
    const cfg = WEAPON_CONFIG[key];
    if (!cfg || !cfg.levels || !cfg.levels.length) return 1;
    return cfg.levels.length;
  }

  // ===== ITEM SHOP (Gold) =====
  const ITEM_PRODUCTS = {
    heal_full: {
      id: 'heal_full',
      type: 'heal',
      title: 'H·ªìi 50 HP',
      description: 'H·ªìi 50 HP trong tr·∫≠n hi·ªán t·∫°i (kh√¥ng v∆∞·ª£t qu√° HP t·ªëi ƒëa).',
      priceGold: 20   // 2‚≠ê *10
    },
    armor_plus: {
      id: 'armor_plus',
      type: 'armor',
      title: 'Gi√°p vƒ©nh vi·ªÖn +20 HP',
      description: 'TƒÉng HP t·ªëi ƒëa (√°p d·ª•ng ngay) cho t·∫•t c·∫£ tr·∫≠n sau n√†y.',
      priceGold: 120  // 12‚≠ê
    },
    revive_continue: {
      id: 'revive_continue',
      type: 'revive',
      title: 'Ch∆°i ti·∫øp m√†n v·ª´a thua',
      description: 'H·ªìi sinh trong ·∫£i v·ª´a thua (m·ªói ·∫£i t·ªëi ƒëa 1 l·∫ßn).',
      priceGold: 100  // 10‚≠ê
    },
    firestorm: {
      id: 'firestorm',
      type: 'firestorm',
      title: 'B√£o l·ª≠a',
      description: 'Qu√©t s·∫°ch ƒë·∫°n ƒë·ªãch v√† ƒë·ªët 10% m√°u m·ªói qu√°i. C√≥ th·ªÉ mua nhi·ªÅu l·∫ßn.',
      priceGold: 40   // 4‚≠ê cho m·ªói l·∫ßn
    },
    unlock_rifle: {
      id: 'unlock_rifle',
      type: 'unlockWeapon',
      weaponKey: 'rifle',
      title: 'M·ªü kh√≥a Rifle',
      description: 'S√∫ng b·∫Øn nhanh, DPS cao h∆°n Pistol.',
      priceGold: 300
    },
    unlock_shotgun: {
      id: 'unlock_shotgun',
      type: 'unlockWeapon',
      weaponKey: 'shotgun',
      title: 'M·ªü kh√≥a Shotgun',
      description: 'B·∫Øn loe nhi·ªÅu vi√™n, d·ªçn qu√°i g·∫ßn c·ª±c t·ªët.',
      priceGold: 400
    },
    unlock_sniper: {
      id: 'unlock_sniper',
      type: 'unlockWeapon',
      weaponKey: 'sniper',
      title: 'M·ªü kh√≥a Sniper',
      description: 'S√°t th∆∞∆°ng c·ª±c cao, ƒë·∫°n t·ª± d√≤ m·ª•c ti√™u.',
      priceGold: 500
    },
    upgrade_pistol: {
      id: 'upgrade_pistol',
      type: 'upgradeWeapon',
      weaponKey: 'pistol',
      baseGold: 150
    },
    upgrade_rifle: {
      id: 'upgrade_rifle',
      type: 'upgradeWeapon',
      weaponKey: 'rifle',
      baseGold: 180
    },
    upgrade_shotgun: {
      id: 'upgrade_shotgun',
      type: 'upgradeWeapon',
      weaponKey: 'shotgun',
      baseGold: 200
    },
    upgrade_sniper: {
      id: 'upgrade_sniper',
      type: 'upgradeWeapon',
      weaponKey: 'sniper',
      baseGold: 250
    }
  };

  // ===== STARS ‚Üí GOLD PACKS =====
  const STARS_GOLD_PACKS = [
    { id: 'pack_5',   stars: 5,   gold:  50 },
    { id: 'pack_10',  stars:10,   gold: 100 },
    { id: 'pack_20',  stars:20,   gold: 200 },
    { id: 'pack_50',  stars:50,   gold: 500 },
    { id: 'pack_100', stars:100,  gold:1000 },
    { id: 'pack_200', stars:200,  gold:2000 },
    { id: 'pack_500', stars:500,  gold:5000 },
    { id: 'pack_1000',stars:1000, gold:10000 },
  ];

  // ===== PROGRESS =====
  function loadProgress() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (e) {
      return null;
    }
  }
  function saveProgress() {
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(progress)); } catch (e) {}
  }

  const defaultProgress = {
    unlockedWeapons: { pistol: true, rifle: false, shotgun: false, sniper: false },
    weaponLevels:    { pistol: 1,    rifle: 0,     shotgun: 0,     sniper: 0     },
    armorLevel: 0,
    bestStage: 0,
    firestormCharges: 0,
    gold: 0
  };
  let progress = loadProgress() || defaultProgress;

  function ensureProgressShape() {
    if (!progress.unlockedWeapons) {
      progress.unlockedWeapons = { pistol:true, rifle:false, shotgun:false, sniper:false };
    }
    if (!progress.weaponLevels) {
      progress.weaponLevels = { pistol:1, rifle:0, shotgun:0, sniper:0 };
    }
    if (progress.armorLevel == null) progress.armorLevel = 0;
    if (progress.bestStage == null) progress.bestStage = 0;
    if (progress.firestormCharges == null) progress.firestormCharges = 0;
    if (progress.gold == null) progress.gold = 0;

    for (const key of WEAPON_KEYS) {
      const maxLv = getMaxWeaponLevel(key);
      let lv = progress.weaponLevels[key] || (progress.unlockedWeapons[key] ? 1 : 0);
      if (lv > maxLv) lv = maxLv;
      progress.weaponLevels[key] = lv;
    }
  }
  ensureProgressShape();
  saveProgress();

  // ===== GAME STATE =====
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const hudStage      = document.getElementById('hudStage');
  const hpFill        = document.getElementById('hpFill');
  const hudHpText     = document.getElementById('hudHpText');
  const hudWeaponName = document.getElementById('hudWeaponName');
  const hudWeaponLevel= document.getElementById('hudWeaponLevel');
  const hudGold       = document.getElementById('hudGold');
  const btnShopHud    = document.getElementById('btnOpenShopHud');
  const btnWeapon     = document.getElementById('btnWeapon');
  const btnPauseHud   = document.getElementById('btnPauseHud');
  const overlay       = document.getElementById('overlay');
  const btnShoot      = document.getElementById('btnShoot');
  const firestormLabel= document.getElementById('firestormCountLabel');

  const keys = { left: false, right: false, up: false, down: false, shoot: false };

  const BASE_ENEMY_HP    = 30;
  const BASE_ENEMY_DMG   = 8;
  const BASE_ENEMY_COUNT = 10;
  const ENEMY_PER_STAGE  = 5;

  let gameState = 'menu'; // 'menu','playing','paused','stageClear','gameOver'
  let stage = 1;
  let reviveUsedThisStage = false;
  let shopReturnMode = 'menu';
  let shopActiveTab  = 'items'; // 'stars' | 'items'
  let firestormFlashTimer = 0;

  const player = {
    x: canvas.width / 2,
    y: canvas.height - 90,
    width: 60,
    height: 80,
    speed: 260,
    hp: 100,
    maxHp: 100,
    weaponKey: 'pistol',
    shotTimer: 0,
    moveDir: 0,
    shootFlashTimer: 0
  };

  let enemies = [];
  let playerBullets = [];
  let enemyBullets  = [];

  // ===== SPRITES =====
  const spritePlayer = new Image();
  spritePlayer.src = 'player.png';
  const spriteEnemy = new Image();
  spriteEnemy.src  = 'enemy_girl.png';
  const spriteBoss  = new Image();
  spriteBoss.src   = 'boss_girl.png';

  function isSpriteReady(img) {
    return img && img.complete && img.naturalWidth > 0;
  }

  // ===== AUDIO (m·ªõi, s√∫ng tr·∫ßm h∆°n + th√™m SFX) =====
  let audioCtx = null;
  let masterGain = null;
  let audioEnabled = true;

  function ensureAudio() {
    if (!audioEnabled) return;
    if (!audioCtx) {
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.7;
        masterGain.connect(audioCtx.destination);
      } catch (e) {
        audioEnabled = false;
      }
    }
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  }

  function playTone(freq, duration, type = 'sine', gainValue = 0.3) {
    if (!audioEnabled || !audioCtx || !masterGain) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    osc.connect(gain);
    gain.connect(masterGain);
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.linearRampToValueAtTime(gainValue, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
    osc.start(now);
    osc.stop(now + duration + 0.05);
  }

  function playNoise(duration = 0.15, volume = 0.3) {
    if (!audioEnabled || !audioCtx || !masterGain) return;
    const bufferSize = audioCtx.sampleRate * duration;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = (Math.random()*2 - 1) * (1 - i/bufferSize);
    }
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    const gain = audioCtx.createGain();
    src.connect(gain);
    gain.connect(masterGain);
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(volume, now);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
    src.start(now);
    src.stop(now + duration + 0.05);
  }

  function playSweep(startFreq, endFreq, duration = 0.2, type = 'sawtooth', volume = 0.3) {
    if (!audioEnabled || !audioCtx || !masterGain) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    const now = audioCtx.currentTime;
    osc.frequency.setValueAtTime(startFreq, now);
    osc.frequency.linearRampToValueAtTime(endFreq, now + duration);
    osc.connect(gain);
    gain.connect(masterGain);
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.linearRampToValueAtTime(volume, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
    osc.start(now);
    osc.stop(now + duration + 0.05);
  }

  // Click UI
  function playClickSound() {
    ensureAudio();
    if (!audioCtx || !audioEnabled) return;
    playTone(800, 0.05, 'triangle', 0.15);
  }

  // S√∫ng: d√πng ti·∫øng s√∫ng ban ƒë·∫ßu, nh∆∞ng tr·∫ßm h∆°n + b·ªõt ch√≥i
  function playShotSound() {
    ensureAudio();
    if (!audioCtx || !audioEnabled) return;
    // ti·∫øng "b·ª•p" + m·ªôt ch√∫t noise
    playNoise(0.04, 0.25);
    playTone(420, 0.06, 'square', 0.18);
  }

  // Hit (ƒë·∫°n tr√∫ng m·ª•c ti√™u)
  function playHitSound() {
    ensureAudio();
    if (!audioCtx || !audioEnabled) return;
    playTone(500, 0.05, 'sawtooth', 0.18);
  }

  // N·ªï m·∫°nh (d√πng cho firestorm / boss ch·∫øt ph·ª•)
  function playExplosionSound() {
    ensureAudio();
    if (!audioCtx || !audioEnabled) return;
    playNoise(0.25, 0.35);
    playSweep(220, 80, 0.25, 'triangle', 0.28);
  }

  // Player tr√∫ng ƒë·∫°n (gi·ªëng file sound test: ki·ªÉu "·ª£" nam)
  function sfxPlayerHit() {
    ensureAudio();
    if (!audioCtx || !audioEnabled) return;
    playSweep(260, 140, 0.18, 'triangle', 0.35);
    setTimeout(() => {
      playTone(110, 0.08, 'sine', 0.25);
    }, 120);
  }

  // Qu√°i nh·ªè ch·∫øt
  function sfxEnemyDieSmall() {
    ensureAudio();
    if (!audioCtx || !audioEnabled) return;
    // ch√∫t "r√™n" + noise nh·∫π
    playSweep(650, 900, 0.12, 'sawtooth', 0.32);
    setTimeout(() => playNoise(0.07, 0.2), 40);
  }

  // Boss ch·∫øt
  function sfxBossDie() {
    ensureAudio();
    if (!audioCtx || !audioEnabled) return;
    playSweep(620, 980, 0.22, 'triangle', 0.36);
    setTimeout(() => {
      playTone(700, 0.22, 'sine', 0.3);
    }, 160);
    setTimeout(() => playNoise(0.18, 0.26), 130);
  }

  // Clear stage: c∆∞·ªùi vui
  function sfxStageClearLaugh() {
    ensureAudio();
    if (!audioCtx || !audioEnabled) return;
    const pattern = [
      { f: 380, d: 0.09 },
      { f: 520, d: 0.09 },
      { f: 660, d: 0.12 },
      { f: 580, d: 0.12 },
      { f: 720, d: 0.16 }
    ];
    let delay = 0;
    pattern.forEach(note => {
      setTimeout(() => playTone(note.f, note.d, 'square', 0.32), delay);
      delay += note.d * 650;
    });
  }

  // Game over: c∆∞·ªùi ch·∫ø nh·∫°o h∆°n
  function sfxGameOverTease() {
    ensureAudio();
    if (!audioCtx || !audioEnabled) return;
    const groups = [
      { freqs: [760, 840, 880], gap: 55 },
      { freqs: [800, 880, 920], gap: 55 },
      { freqs: [840, 920, 960], gap: 55 }
    ];
    let baseDelay = 0;
    groups.forEach(g => {
      g.freqs.forEach((f, idx) => {
        setTimeout(() => playTone(f, 0.07, 'square', 0.3), baseDelay + idx*g.gap);
      });
      setTimeout(() => playSweep(g.freqs[g.freqs.length-1],
                                 g.freqs[g.freqs.length-1] + 140,
                                 0.09,'triangle',0.28),
                 baseDelay + g.freqs.length*g.gap + 20);
      baseDelay += g.freqs.length*g.gap + 140;
    });
    setTimeout(() => playSweep(780, 360, 0.42, 'sawtooth', 0.3), baseDelay + 80);
  }

  // ===== UTIL HUD =====
  function getWeaponStats(key) {
    const cfg = WEAPON_CONFIG[key] || WEAPON_CONFIG.pistol;
    const maxLv = getMaxWeaponLevel(key);
    let level = progress.weaponLevels[key] || 1;
    if (level < 1) level = 1;
    if (level > maxLv) level = maxLv;
    const idx = level - 1;
    return cfg.levels[idx];
  }
  function updateHudWeapon() {
    const cfg = WEAPON_CONFIG[player.weaponKey];
    const lv  = progress.weaponLevels[player.weaponKey] || 1;
    hudWeaponName.textContent  = cfg.displayName;
    hudWeaponLevel.textContent = 'Lv.' + lv;
  }
  function updateFirestormHud() {
    const c = progress.firestormCharges || 0;
    firestormLabel.textContent = 'x' + c;
    btnShoot.style.opacity = c > 0 ? '1' : '0.5';
  }
  function updateGoldHud() {
    hudGold.textContent = progress.gold.toString();
  }
  function resetPlayer() {
    player.x = canvas.width / 2;
    player.y = canvas.height - 90;
    player.weaponKey = 'pistol';
    player.shotTimer = 0;
    player.moveDir = 0;
    player.shootFlashTimer = 0;
    player.maxHp = 100 + progress.armorLevel * 20;
    player.hp = player.maxHp;
    updateHudWeapon();
  }

  function createStage(n) {
    enemies = [];
    playerBullets = [];
    enemyBullets  = [];

    const count = (n === 1) ? BASE_ENEMY_COUNT : BASE_ENEMY_COUNT + (n-1)*ENEMY_PER_STAGE;
    const hpMul  = Math.pow(1.2, n-1);
    const dmgMul = Math.pow(1.1, n-1);

    for (let i=0;i<count;i++) {
      enemies.push({
        x: 30 + Math.random()*(canvas.width-60),
        y: 60 + Math.random()*180,
        width: 60,
        height: 80,
        hp: BASE_ENEMY_HP*hpMul,
        maxHp: BASE_ENEMY_HP*hpMul,
        speedX: (Math.random()<0.5?-1:1)*(20+Math.random()*30),
        damage: BASE_ENEMY_DMG*dmgMul,
        shootTimer: 1 + Math.random()*2,
        type: 'normal',
        bobPhase: Math.random()*Math.PI*2,
        hitTimer: 0
      });
    }
    if (n % 2 === 0) {
      enemies.push({
        x: canvas.width/2,
        y: 80,
        width: 76,
        height: 96,
        hp: BASE_ENEMY_HP*hpMul*6,
        maxHp: BASE_ENEMY_HP*hpMul*6,
        speedX: 35,
        damage: BASE_ENEMY_DMG*dmgMul*1.5,
        shootTimer: 1.2,
        type: 'miniBoss',
        bobPhase: Math.random()*Math.PI*2,
        hitTimer: 0
      });
    }
    if (n % 10 === 0) {
      enemies.push({
        x: canvas.width/2,
        y: 95,
        width: 90,
        height: 112,
        hp: BASE_ENEMY_HP*hpMul*14,
        maxHp: BASE_ENEMY_HP*hpMul*14,
        speedX: 30,
        damage: BASE_ENEMY_DMG*dmgMul*2,
        shootTimer: 0.9,
        type: 'boss',
        bobPhase: Math.random()*Math.PI*2,
        hitTimer: 0
      });
    }
    hudStage.textContent = n;
    reviveUsedThisStage = false;
  }

  function startGame() {
    playClickSound();
    stage = 1;
    resetPlayer();
    createStage(stage);
    gameState = 'playing';
    hideOverlay();
  }
  function nextStage() {
    playClickSound();
    stage += 1;
    if (stage > progress.bestStage) { progress.bestStage = stage; saveProgress(); }
    player.hp = Math.min(player.hp + 30, player.maxHp);
    createStage(stage);
    gameState = 'playing';
    hideOverlay();
  }

  // ===== OVERLAY =====
  function showMainMenu() {
    gameState = 'menu';
    shopReturnMode = 'menu';
    overlay.innerHTML = `
      <h1>üéÆ Survival Shooter</h1>
      <p>Game b·∫Øn s√∫ng sinh t·ªìn. D√πng Telegram Stars ƒë·ªÉ mua Gold, sau ƒë√≥ d√πng Gold mua v·∫≠t ph·∫©m v√† n√¢ng c·∫•p v≈© kh√≠.</p>
      <p style="font-size:13px;opacity:0.9">
        <b>PC:</b> WASD / ph√≠m m≈©i t√™n ƒë·ªÉ di chuy·ªÉn, auto-b·∫Øn. Nh·∫•n <b>Q</b> ho·∫∑c n√∫t s√∫ng ƒë·ªÉ ƒë·ªïi v≈© kh√≠.<br/>
        <b>ƒêi·ªán tho·∫°i:</b> Vu·ªët tr√™n m√†n h√¨nh (k√©o nh√¢n v·∫≠t) ƒë·ªÉ di chuy·ªÉn t·ª± do, n√∫t üî• ƒë·ªÉ d√πng B√£o l·ª≠a.
      </p>
      <button id="btnStartGame">B·∫Øt ƒë·∫ßu ·∫£i 1</button>
      <button id="btnOpenShopFromMenu" class="secondary">üõí M·ªü Shop</button>
      <small>Tip: 1‚≠ê ‚âà 10 Gold. B·∫°n c√≥ th·ªÉ mua Stars b·∫±ng Ton / ti·ªÅn trong v√≠ Telegram.</small>
    `;
    overlay.style.display = 'flex';
    document.getElementById('btnStartGame').onclick = () => { ensureAudio(); startGame(); };
    document.getElementById('btnOpenShopFromMenu').onclick = () => { ensureAudio(); showShop('items', null, 'menu'); };
  }
  function showStageClear() {
    gameState = 'stageClear';
    shopReturnMode = 'stageClear';
    overlay.innerHTML = `
      <h1>‚úÖ Ho√†n th√†nh ·∫£i ${stage}</h1>
      <p>B·∫°n ƒë√£ s·ªëng s√≥t qua ·∫£i <b>${stage}</b>! Qu√°i ·∫£i sau s·∫Ω ƒë√¥ng & tr√¢u h∆°n.</p>
      <button id="btnNextStage">Ti·∫øp t·ª•c ·∫£i ${stage+1}</button>
      <button id="btnOpenShopFromStage" class="secondary">üõí M·ªü Shop</button>
    `;
    overlay.style.display = 'flex';
    document.getElementById('btnNextStage').onclick = () => { ensureAudio(); nextStage(); };
    document.getElementById('btnOpenShopFromStage').onclick = () => { ensureAudio(); showShop('items', null, 'stageClear'); };
  }
  function showGameOver() {
    gameState = 'gameOver';
    shopReturnMode = 'gameOver';
    overlay.innerHTML = `
      <h1>üíÄ Game Over</h1>
      <p>B·∫°n d·ª´ng l·∫°i ·ªü ·∫£i <b>${stage}</b>. C√≥ th·ªÉ d√πng <b>Revive</b> ho·∫∑c n√¢ng c·∫•p s√∫ng / B√£o l·ª≠a ƒë·ªÉ ƒëi xa h∆°n!</p>
      <button id="btnRetry">Ch∆°i l·∫°i t·ª´ ·∫£i 1</button>
      <button id="btnOpenShopFromOver" class="secondary">üõí M·ªü Shop (Revive / B√£o l·ª≠a)</button>
    `;
    overlay.style.display = 'flex';
    document.getElementById('btnRetry').onclick = () => { ensureAudio(); startGame(); };
    document.getElementById('btnOpenShopFromOver').onclick = () => { ensureAudio(); showShop('items', null, 'gameOver'); };
  }
  function showPauseOverlay() {
    gameState = 'paused';
    shopReturnMode = 'pause';
    overlay.innerHTML = `
      <h1>‚è∏ T·∫°m d·ª´ng</h1>
      <p>B·∫°n ƒëang ·ªü ·∫£i <b>${stage}</b>. Gold hi·ªán t·∫°i: <b>${progress.gold}</b>.</p>
      <button id="btnResume">Ti·∫øp t·ª•c ch∆°i</button>
      <button id="btnPauseShop" class="secondary">üõí M·ªü Shop</button>
      <button id="btnPauseToMenu" class="secondary">üè† V·ªÅ menu ch√≠nh</button>
    `;
    overlay.style.display = 'flex';
    document.getElementById('btnResume').onclick = () => {
      ensureAudio(); playClickSound(); hideOverlay(); gameState = 'playing';
    };
    document.getElementById('btnPauseShop').onclick = () => {
      ensureAudio(); showShop('items', null, 'pause');
    };
    document.getElementById('btnPauseToMenu').onclick = () => {
      ensureAudio(); playClickSound(); showMainMenu();
    };
  }
  function hideOverlay() { overlay.style.display = 'none'; }

  // ===== SHOP COMMON =====
  function setShopStatus(text, isError) {
    const el = document.getElementById('shopStatusText');
    if (!el) return;
    el.textContent = text;
    el.style.color = isError ? '#ff8080' : '#ffffff';
  }

  // ===== STARS ‚Üí GOLD SHOP LOGIC =====
  async function createStarsInvoice(stars, payload, title, description) {
    const r = await fetch(BACKEND + '/api/create-invoice', {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({
        title: title || 'Mua Gold',
        description: description || 'Mua Gold d√πng trong game b·∫±ng Telegram Stars.',
        price_stars: stars,
        payload
      })
    });
    return r.json();
  }
  async function deliverReward(payload) {
    try {
      const r = await fetch(BACKEND + '/api/deliver', {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({ payload })
      });
      return r.json();
    } catch (e) { return { ok:false, error:e.message }; }
  }

  function applyGold(amount) {
    progress.gold += amount;
    saveProgress();
    updateGoldHud();
  }

  async function buyGoldPack(packId) {
    const pack = STARS_GOLD_PACKS.find(p => p.id === packId);
    if (!pack) return;
    const stars = pack.stars;
    const gold  = pack.gold;

    if (DEV_FREE_STARS) {
      console.log('[DEV] Fake buy gold pack:', packId);
      applyGold(gold);
      setShopStatus(`(DEV) ƒê√£ c·ªông ${gold} Gold (g√≥i ${stars}‚≠ê).`, false);
      return;
    }

    if (!inTelegram()) {
      alert('B·∫°n ch·ªâ c√≥ th·ªÉ mua Gold b·∫±ng Stars khi m·ªü game trong Telegram.');
      return;
    }

    try {
      setShopStatus('ƒêang t·∫°o ho√° ƒë∆°n Stars...', false);
      const payload = 'gold-pack-'+packId+'-'+Date.now();
      const j = await createStarsInvoice(stars, payload,
        `Mua ${gold} Gold`,
        `G√≥i ${stars}‚≠ê ƒë·ªïi th√†nh ${gold} Gold trong game.`
      );
      if (!j.ok || !j.invoiceLink) {
        setShopStatus('Kh√¥ng t·∫°o ƒë∆∞·ª£c invoice: '+(j.error||'unknown'), true); return;
      }
      const link = j.invoiceLink;
      tg.openInvoice(link, async (status) => {
        const st = typeof status === 'string' ? status : status && status.status;
        console.log('openInvoice gold pack status =', st);
        if (st === 'paid') {
          setShopStatus('Thanh to√°n th√†nh c√¥ng, ƒëang c·ªông Gold...', false);
          try { await deliverReward(payload); } catch(e){}
          applyGold(gold);
          setShopStatus(`ƒê√£ c·ªông ${gold} Gold v√†o t√†i kho·∫£n.`, false);
        } else if (st === 'cancelled') {
          setShopStatus('B·∫°n ƒë√£ ƒë√≥ng c·ª≠a s·ªï thanh to√°n.', true);
        } else if (st === 'failed') {
          setShopStatus('Telegram b√°o l·ªói thanh to√°n (failed).', true);
        } else {
          setShopStatus('Thanh to√°n kh√¥ng th√†nh c√¥ng, tr·∫°ng th√°i: '+st, true);
        }
      });
    } catch (e) {
      console.error(e);
      setShopStatus('L·ªói khi t·∫°o/m·ªü invoice: '+e.message, true);
    }
  }

  // ===== ITEM SHOP (Gold) LOGIC =====
  function getItemPriceGold(id, qty) {
    const p = ITEM_PRODUCTS[id]; if (!p) return null;
    qty = qty || 1;
    if (p.type === 'upgradeWeapon') {
      const wl = progress.weaponLevels[p.weaponKey] || 1;
      const maxLv = getMaxWeaponLevel(p.weaponKey);
      if (!progress.unlockedWeapons[p.weaponKey]) return null;
      if (wl >= maxLv) return null;
      return p.baseGold * wl;
    }
    if (p.type === 'firestorm') {
      return p.priceGold * qty;
    }
    return p.priceGold || null;
  }

  function getItemStateText(p) {
    if (p.type === 'unlockWeapon') {
      const unlocked = !!progress.unlockedWeapons[p.weaponKey];
      return unlocked ? 'ƒê√£ m·ªü kh√≥a' : 'Ch∆∞a s·ªü h·ªØu';
    }
    if (p.type === 'upgradeWeapon') {
      const lvl = progress.weaponLevels[p.weaponKey] || 1;
      const maxLv = getMaxWeaponLevel(p.weaponKey);
      if (!progress.unlockedWeapons[p.weaponKey]) return 'Ch∆∞a m·ªü kh√≥a v≈© kh√≠ n√†y';
      if (lvl >= maxLv) return `ƒê√£ t·ªëi ƒëa (Lv.${lvl})`;
      return `Hi·ªán t·∫°i: Lv.${lvl}`;
    }
    if (p.type === 'heal') {
      return 'H·ªìi 50 HP trong tr·∫≠n hi·ªán t·∫°i';
    }
    if (p.type === 'armor') {
      return `Gi√°p hi·ªán t·∫°i: +${progress.armorLevel*20} HP t·ªëi ƒëa`;
    }
    if (p.type === 'revive') {
      return 'Ch·ªâ d√πng khi v·ª´a thua 1 ·∫£i (m·ªói ·∫£i 1 l·∫ßn)';
    }
    if (p.type === 'firestorm') {
      return `ƒêang c√≥: ${progress.firestormCharges || 0} l·∫ßn B√£o l·ª≠a`;
    }
    return '';
  }

  function canBuyItemGold(id, qtyForCheck) {
    const p = ITEM_PRODUCTS[id]; if (!p) return false;
    const qty = qtyForCheck || 1;
    const price = getItemPriceGold(id, qty);
    if (price == null) return false;
    if (progress.gold < price) return false;

    if (p.type === 'heal') {
      if (!(gameState === 'playing' || gameState === 'paused')) return false;
      if (player.hp >= player.maxHp) return false;
      return true;
    }
    if (p.type === 'armor') return true;
    if (p.type === 'revive') {
      if (gameState !== 'gameOver') return false;
      if (reviveUsedThisStage) return false;
      return true;
    }
    if (p.type === 'firestorm') {
      return true;
    }
    if (p.type === 'unlockWeapon') {
      if (progress.unlockedWeapons[p.weaponKey]) return false;
      return true;
    }
    if (p.type === 'upgradeWeapon') {
      if (!progress.unlockedWeapons[p.weaponKey]) return false;
      const lvl = progress.weaponLevels[p.weaponKey] || 1;
      const maxLv = getMaxWeaponLevel(p.weaponKey);
      if (lvl >= maxLv) return false;
      return true;
    }
    return true;
  }

  function applyItemEffect(id, qty) {
    const p = ITEM_PRODUCTS[id]; if (!p) return;
    qty = qty || 1;

    if (p.type === 'heal') {
      player.hp = Math.min(player.maxHp, player.hp + 50);
      showShop('items', 'ƒê√£ h·ªìi 50 HP cho tr·∫≠n hi·ªán t·∫°i.', shopReturnMode);
      return;
    }
    if (p.type === 'armor') {
      progress.armorLevel += 1;
      player.maxHp = 100 + progress.armorLevel * 20;
      player.hp = Math.min(player.maxHp, player.hp + 20);
      saveProgress();
      updateHud();
      showShop('items', 'ƒê√£ tƒÉng gi√°p vƒ©nh vi·ªÖn (+20 HP t·ªëi ƒëa, √°p d·ª•ng ngay).', shopReturnMode);
      return;
    }
    if (p.type === 'revive') {
      if (gameState !== 'gameOver' || reviveUsedThisStage) {
        showShop('items', 'Revive ch·ªâ d√πng ƒë∆∞·ª£c ngay sau khi thua v√† m·ªói ·∫£i 1 l·∫ßn.', shopReturnMode);
        return;
      }
      reviveUsedThisStage = true;
      player.hp = player.maxHp * 0.7;
      enemyBullets = [];
      gameState = 'playing';
      hideOverlay();
      playExplosionSound();
      return;
    }
    if (p.type === 'firestorm') {
      progress.firestormCharges = (progress.firestormCharges || 0) + qty;
      saveProgress();
      updateFirestormHud();
      showShop('items', `ƒê√£ mua th√™m ${qty} l·∫ßn B√£o l·ª≠a.`, shopReturnMode);
      return;
    }
    if (p.type === 'unlockWeapon') {
      progress.unlockedWeapons[p.weaponKey] = true;
      if (!progress.weaponLevels[p.weaponKey] || progress.weaponLevels[p.weaponKey]<=0) {
        progress.weaponLevels[p.weaponKey] = 1;
      }
      saveProgress();
      updateHudWeapon();
      showShop('items', 'Mua th√†nh c√¥ng! V≈© kh√≠ m·ªõi ƒë√£ ƒë∆∞·ª£c m·ªü kh√≥a.', shopReturnMode);
      return;
    }
    if (p.type === 'upgradeWeapon') {
      if (!progress.unlockedWeapons[p.weaponKey]) {
        showShop('items', 'Ch∆∞a m·ªü kh√≥a v≈© kh√≠ n√†y.', shopReturnMode);
        return;
      }
      const maxLv = getMaxWeaponLevel(p.weaponKey);
      const lvl = progress.weaponLevels[p.weaponKey] || 1;
      if (lvl >= maxLv) {
        showShop('items', 'V≈© kh√≠ n√†y ƒë√£ t·ªëi ƒëa.', shopReturnMode);
        return;
      }
      progress.weaponLevels[p.weaponKey] = Math.min(maxLv, lvl+1);
      saveProgress();
      if (player.weaponKey === p.weaponKey) updateHudWeapon();
      showShop('items', 'N√¢ng c·∫•p th√†nh c√¥ng! V≈© kh√≠ m·∫°nh h∆°n r·ªìi.', shopReturnMode);
      return;
    }
  }

  function buyItemGold(id, qty) {
    qty = qty || 1;
    const price = getItemPriceGold(id, qty);
    if (price == null) {
      setShopStatus('M·ª•c n√†y hi·ªán kh√¥ng th·ªÉ mua.', true); return;
    }
    if (!canBuyItemGold(id, qty)) {
      if (progress.gold < price) {
        setShopStatus('Kh√¥ng ƒë·ªß Gold ƒë·ªÉ mua.', true);
      } else {
        setShopStatus('M·ª•c n√†y hi·ªán kh√¥ng kh·∫£ d·ª•ng trong tr·∫°ng th√°i hi·ªán t·∫°i.', true);
      }
      return;
    }
    progress.gold -= price;
    saveProgress();
    updateGoldHud();
    setShopStatus(`ƒê√£ tr·ª´ ${price} Gold.`, false);
    applyItemEffect(id, qty);
  }

  // ===== SHOP UI RENDER =====
  function buildStarsShopRows() {
    const rows = [];
    for (const pack of STARS_GOLD_PACKS) {
      rows.push(`
        <div class="shop-item">
          <div class="shop-item-header">
            <span class="shop-item-title">G√≥i ${pack.stars}‚≠ê ‚Üí ${pack.gold} Gold</span>
          </div>
          <div class="shop-item-desc">
            D√πng ${pack.stars} Telegram Stars ƒë·ªÉ nh·∫≠n ${pack.gold} Gold trong game (1‚≠ê = 10 Gold).
          </div>
          <div class="shop-item-footer">
            <div class="shop-price">
              <span>Gi√°:</span>
              <b>${pack.stars} ‚≠ê</b>
            </div>
            <button
              class="secondary"
              data-pack-id="${pack.id}"
              style="padding:6px 10px;border-radius:999px;font-size:12px;">
              Mua b·∫±ng Stars
            </button>
          </div>
        </div>
      `);
    }
    return rows.join('');
  }

  function buildItemsShopRows() {
    const rows = [];

    // Heal
    rows.push(renderItemRow('heal_full', '20 ü™ô', 1));
    // Armor
    rows.push(renderItemRow('armor_plus', '120 ü™ô', 1));
    // Revive
    rows.push(renderItemRow('revive_continue', '100 ü™ô', 1));
    // Firestorm
    rows.push(renderItemRow('firestorm', '40 ü™ô / 1 l·∫ßn', 1, true));

    function pushWeaponSlot(weaponKey, unlockId, upgradeId) {
      const unlocked = !!progress.unlockedWeapons[weaponKey];
      const maxLv = getMaxWeaponLevel(weaponKey);
      const lvl = progress.weaponLevels[weaponKey] || (unlocked ? 1 : 0);
      if (!unlocked) {
        const price = ITEM_PRODUCTS[unlockId].priceGold;
        rows.push(renderItemRow(unlockId, `${price} ü™ô`, 1));
      } else if (lvl < maxLv) {
        const price = getItemPriceGold(upgradeId, 1);
        rows.push(renderItemRow(upgradeId, `${price} ü™ô (n√¢ng l√™n Lv.${lvl+1})`, 1));
      } else {
        // max -> ·∫©n
      }
    }

    pushWeaponSlot('rifle',   'unlock_rifle',   'upgrade_rifle');
    pushWeaponSlot('shotgun', 'unlock_shotgun', 'upgrade_shotgun');
    pushWeaponSlot('sniper',  'unlock_sniper',  'upgrade_sniper');

    const pistolMaxLv = getMaxWeaponLevel('pistol');
    const pistolLv = progress.weaponLevels.pistol || 1;
    if (pistolLv < pistolMaxLv) {
      const price = getItemPriceGold('upgrade_pistol', 1);
      rows.push(renderItemRow('upgrade_pistol', `${price} ü™ô (n√¢ng l√™n Lv.${pistolLv+1})`, 1));
    }

    return rows.join('');
  }

  function renderItemRow(id, priceLabel, qtyForButton, isFirestorm) {
    const p = ITEM_PRODUCTS[id];
    const stateText = getItemStateText(p);
    const buyable = canBuyItemGold(id, qtyForButton || 1);
    const labelBtn = buyable ? (isFirestorm ? 'Mua B√£o l·ª≠a' : 'Mua') : 'Kh√¥ng th·ªÉ mua';
    const disabledAttr = buyable ? '' : 'disabled style="opacity:0.5;cursor:not-allowed;"';

    return `
      <div class="shop-item">
        <div class="shop-item-header">
          <span class="shop-item-title">${p.title || ('Item '+p.id)}</span>
          <span style="font-size:11px;opacity:0.8;">${p.type}</span>
        </div>
        <div class="shop-item-desc">${p.description || ''}</div>
        <div class="shop-item-footer">
          <div class="shop-price">
            <span>Gi√°:</span>
            <b>${priceLabel}</b>
          </div>
          <button
            class="secondary"
            data-item-id="${p.id}"
            ${disabledAttr}
            style="padding:6px 10px;border-radius:999px;font-size:12px;">
            ${labelBtn}
          </button>
        </div>
        <div class="shop-status-text">${stateText}</div>
      </div>
    `;
  }

  function showShop(activeTab, message, returnMode) {
    if (activeTab) shopActiveTab = activeTab;
    if (returnMode) shopReturnMode = returnMode;

    const msg = message || (shopActiveTab === 'stars'
      ? 'D√πng Stars ƒë·ªÉ mua Gold (1‚≠ê = 10 Gold).'
      : 'D√πng Gold ƒë·ªÉ mua h·ªìi m√°u, gi√°p, revive, B√£o l·ª≠a, v≈© kh√≠ v√† n√¢ng c·∫•p.');

    const starsActive = shopActiveTab === 'stars';
    const contentHtml = starsActive ? buildStarsShopRows() : buildItemsShopRows();

    overlay.innerHTML = `
      <h1>üõí Shop</h1>
      <p>Gold hi·ªán t·∫°i: <b>${progress.gold}</b></p>

      <div class="shop-tabs">
        <button id="tabStars" class="shop-tab ${starsActive ? 'active' : ''}">‚≠ê Stars ‚Üí Gold</button>
        <button id="tabItems" class="shop-tab ${!starsActive ? 'active' : ''}">ü™ô Gold ‚Üí V·∫≠t ph·∫©m</button>
      </div>

      <p style="font-size:13px;opacity:0.9;">${msg}</p>

      <div class="shop-list">
        ${contentHtml}
      </div>

      <button id="btnBackFromShop" class="secondary">‚¨Ö Quay l·∫°i</button>
      <small id="shopStatusText" style="margin-top:4px;">
        D√πng Stars ƒë·ªÉ mua Gold, sau ƒë√≥ d√πng Gold ƒë·ªÉ mua v·∫≠t ph·∫©m trong game.
      </small>
    `;
    overlay.style.display = 'flex';

    document.getElementById('tabStars').onclick = () => {
      ensureAudio(); playClickSound();
      showShop('stars', null, shopReturnMode);
    };
    document.getElementById('tabItems').onclick = () => {
      ensureAudio(); playClickSound();
      showShop('items', null, shopReturnMode);
    };

    document.getElementById('btnBackFromShop').onclick = () => {
      playClickSound();
      const mode = shopReturnMode || 'menu';
      if (mode === 'playing') {
        hideOverlay();
        gameState = 'playing';
      } else if (mode === 'pause') {
        showPauseOverlay();
      } else if (mode === 'menu') {
        showMainMenu();
      } else if (mode === 'stageClear') {
        showStageClear();
      } else if (mode === 'gameOver') {
        showGameOver();
      } else {
        hideOverlay();
      }
    };

    if (starsActive) {
      document.querySelectorAll('.shop-item button[data-pack-id]').forEach(btn => {
        btn.onclick = () => {
          const id = btn.getAttribute('data-pack-id');
          ensureAudio(); playClickSound();
          buyGoldPack(id);
        };
      });
    } else {
      document.querySelectorAll('.shop-item button[data-item-id]').forEach(btn => {
        btn.onclick = () => {
          const id = btn.getAttribute('data-item-id');
          ensureAudio(); playClickSound();
          const p = ITEM_PRODUCTS[id];
          if (p && p.type === 'firestorm') {
            let qty = 1;
            const s = prompt('B·∫°n mu·ªën mua bao nhi√™u l·∫ßn B√£o l·ª≠a? (1 - 10)', '1');
            if (s == null) return;
            const n = parseInt(s, 10);
            if (isNaN(n) || n < 1 || n > 10) {
              setShopStatus('S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá (1-10).', true);
              return;
            }
            qty = n;
            buyItemGold(id, qty);
          } else {
            buyItemGold(id, 1);
          }
        };
      });
    }
  }

  // ===== HUD BUTTONS =====
  btnShopHud.addEventListener('click', () => {
    ensureAudio(); playClickSound();
    if (gameState === 'playing') {
      gameState = 'paused';
      showShop('items', null, 'playing');
    } else {
      showShop('items', null, gameState);
    }
  });

  function cycleWeapon() {
    let idx = WEAPON_KEYS.indexOf(player.weaponKey);
    for (let i = 1; i <= WEAPON_KEYS.length; i++) {
      const nextKey = WEAPON_KEYS[(idx + i) % WEAPON_KEYS.length];
      if (progress.unlockedWeapons[nextKey]) {
        player.weaponKey = nextKey;
        break;
      }
    }
    updateHudWeapon();
  }

  btnWeapon.addEventListener('click', () => {
    ensureAudio();
    playClickSound();
    cycleWeapon();
  });

  btnPauseHud.addEventListener('click', () => {
    ensureAudio();
    playClickSound();
    if (gameState === 'playing' || gameState === 'paused') {
      showPauseOverlay();
    }
  });

  // ===== FIRESTORM SKILL =====
  function useFirestormSkill() {
    if (gameState !== 'playing') return;
    const charges = progress.firestormCharges || 0;
    if (charges <= 0) return;
    progress.firestormCharges = charges - 1;
    saveProgress();
    updateFirestormHud();
    firestormFlashTimer = 0.25;
    playExplosionSound();

    enemyBullets = [];
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      const dmg = e.maxHp * 0.10;
      e.hp -= dmg;
      e.hitTimer = 0.2;
      if (e.hp <= 0) {
        enemies.splice(i,1);
      }
    }
    if (enemies.length === 0) {
      onStageClear();
    }
  }

  btnShoot.addEventListener('click', () => {
    ensureAudio();
    useFirestormSkill();
  });

  // ===== INPUT: KEYBOARD =====
  window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowLeft'  || e.code === 'KeyA') keys.left  = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'ArrowUp'    || e.code === 'KeyW') keys.up    = true;
    if (e.code === 'ArrowDown'  || e.code === 'KeyS') keys.down  = true;

    if (e.code === 'KeyQ') {
      cycleWeapon();
    }
    if (gameState==='menu' && e.code==='Enter') { ensureAudio(); startGame(); }
    else if (gameState==='stageClear' && e.code==='Enter') { ensureAudio(); nextStage(); }
    else if (gameState==='gameOver' && e.code==='Enter') { ensureAudio(); startGame(); }
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowLeft'  || e.code === 'KeyA') keys.left  = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'ArrowUp'    || e.code === 'KeyW') keys.up    = false;
    if (e.code === 'ArrowDown'  || e.code === 'KeyS') keys.down  = false;
  });

  // ===== INPUT: TOUCH / DRAG (2D di chuy·ªÉn) =====
  let isDragging = false;
  function pointerToCanvasPos(ev) {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (canvas.width / rect.width);
    const y = (ev.clientY - rect.top) * (canvas.height / rect.height);
    return { x, y };
  }

  canvas.addEventListener('pointerdown', (ev) => {
    ensureAudio();
    isDragging = true;
    const pos = pointerToCanvasPos(ev);
    movePlayerToPointer(pos);
  });
  canvas.addEventListener('pointermove', (ev) => {
    if (!isDragging) return;
    const pos = pointerToCanvasPos(ev);
    movePlayerToPointer(pos);
  });
  canvas.addEventListener('pointerup',   () => { isDragging = false; });
  canvas.addEventListener('pointerleave',() => { isDragging = false; });

  function movePlayerToPointer(pos) {
    const minX = player.width/2+10;
    const maxX = canvas.width-player.width/2-10;
    const minY = canvas.height*0.35;   // h·∫°n ch·∫ø l√™n qu√° cao
    const maxY = canvas.height-60;

    const targetX = Math.max(minX, Math.min(maxX, pos.x));
    const targetY = Math.max(minY, Math.min(maxY, pos.y));

    const dx = targetX - player.x;
    const dy = targetY - player.y;
    const dirX = Math.sign(dx);
    if (dirX !== 0) player.moveDir = dirX;

    player.x = targetX;
    player.y = targetY;
  }

  // ===== GAME UPDATE =====
  function updatePlayer(dt) {
    let dirX = 0, dirY = 0;
    if (keys.left && !keys.right)  dirX = -1;
    else if (keys.right && !keys.left) dirX = 1;
    if (keys.up && !keys.down)     dirY = -1;
    else if (keys.down && !keys.up) dirY = 1;

    if (dirX !== 0) {
      player.moveDir = dirX;
    } else {
      player.moveDir *= 0.9;
      if (Math.abs(player.moveDir) < 0.01) player.moveDir = 0;
    }

    const speed = player.speed;
    player.x += dirX * speed * dt;
    player.y += dirY * speed * dt;

    const minX = player.width/2+10;
    const maxX = canvas.width-player.width/2-10;
    const minY = canvas.height*0.35;
    const maxY = canvas.height-60;
    player.x = Math.max(minX, Math.min(maxX, player.x));
    player.y = Math.max(minY, Math.min(maxY, player.y));

    const stats = getWeaponStats(player.weaponKey);
    updateHudWeapon();

    if (player.shotTimer > 0) player.shotTimer -= dt;

    const wantShoot = AUTO_SHOOT || keys.shoot;
    if (wantShoot && player.shotTimer <= 0) {
      player.shotTimer = stats.cooldown;
      const originY = player.y - player.height/2 + 10;
      const originX = player.x;
      const pellets = stats.pellets || 1;
      for (let i=0;i<pellets;i++) {
        const spread = (pellets===1)?0:(i-(pellets-1)/2)*18;
        const isSniper = (player.weaponKey === 'sniper');
        playerBullets.push({
          x: originX + spread,
          y: originY,
          radius: isSniper ? 5 : 4,
          vx: 0,
          vy: -stats.bulletSpeed,
          speed: stats.bulletSpeed,
          damage: stats.damage,
          homing: isSniper
        });
      }
      player.shootFlashTimer = 0.08;
      playShotSound();
    }
    if (player.shootFlashTimer > 0) {
      player.shootFlashTimer -= dt;
      if (player.shootFlashTimer < 0) player.shootFlashTimer = 0;
    }
  }

  function updateEnemies(dt) {
    for (let i=enemies.length-1;i>=0;i--) {
      const e = enemies[i];
      e.x += e.speedX * dt;
      if (e.x < e.width/2 + 10) { e.x = e.width/2 + 10; e.speedX *= -1; }
      else if (e.x > canvas.width - e.width/2 - 10) { e.x = canvas.width - e.width/2 - 10; e.speedX *= -1; }

      e.shootTimer -= dt;
      if (e.shootTimer <= 0) {
        e.shootTimer = (e.type==='normal') ? (1.3+Math.random()*1.7) : (0.7+Math.random()*1.0);
        enemyBullets.push({
          x:e.x,
          y:e.y + e.height/2 - 10,
          radius:4,
          vy: 200 + (e.type==='boss'?80:0),
          damage:e.damage
        });
      }
      if (e.hitTimer > 0) e.hitTimer -= dt;
    }
  }

  function updateBullets(dt) {
    for (let i=playerBullets.length-1;i>=0;i--) {
      const b = playerBullets[i];
      if (b.homing && enemies.length > 0) {
        let best = null;
        let bestDist = Infinity;
        for (const e of enemies) {
          const dx = e.x - b.x;
          const dy = e.y - b.y;
          const d2 = dx*dx + dy*dy;
          if (d2 < bestDist) {
            bestDist = d2;
            best = e;
          }
        }
        if (best) {
          const dx = best.x - b.x;
          const dy = best.y - b.y;
          let len = Math.hypot(dx, dy) || 1;
          const speed = b.speed || 900;
          const nx = dx / len;
          const ny = dy / len;
          b.vx = nx * speed;
          b.vy = ny * speed;
        }
      }
      b.x += (b.vx || 0) * dt;
      b.y += (b.vy || 0) * dt;

      if (b.y < -30 || b.y > canvas.height+30 || b.x < -30 || b.x > canvas.width+30) {
        playerBullets.splice(i,1);
      }
    }

    for (let i=enemyBullets.length-1;i>=0;i--) {
      const b = enemyBullets[i];
      b.y += b.vy * dt;
      if (b.y > canvas.height+20) enemyBullets.splice(i,1);
    }
  }

  function rectCircleColliding(circle, rect) {
    const distX = Math.abs(circle.x - rect.x);
    const distY = Math.abs(circle.y - rect.y);
    if (distX > (rect.width/2 + circle.radius)) return false;
    if (distY > (rect.height/2 + circle.radius)) return false;
    if (distX <= (rect.width/2)) return true;
    if (distY <= (rect.height/2)) return true;
    const dx = distX - rect.width/2;
    const dy = distY - rect.height/2;
    return (dx*dx + dy*dy <= circle.radius*circle.radius);
  }

  function handleCollisions() {
    // ƒê·∫°n player -> qu√°i
    for (let i=playerBullets.length-1;i>=0;i--) {
      const b = playerBullets[i];
      let hit = false;
      for (let j=enemies.length-1;j>=0;j--) {
        const e = enemies[j];
        if (rectCircleColliding(b, e)) {
          e.hp -= b.damage;
          e.hitTimer = 0.12;
          hit = true;
          playHitSound();
          if (e.hp <= 0) {
            const type = e.type;
            enemies.splice(j,1);
            if (type === 'boss' || type === 'miniBoss') {
              sfxBossDie();
            } else {
              sfxEnemyDieSmall();
            }
          }
          break;
        }
      }
      if (hit) playerBullets.splice(i,1);
    }

    // ƒê·∫°n qu√°i -> player
    for (let i=enemyBullets.length-1;i>=0;i--) {
      const b = enemyBullets[i];
      if (rectCircleColliding(b, player)) {
        enemyBullets.splice(i,1);
        player.hp -= b.damage;
        sfxPlayerHit();
        if (player.hp <= 0) {
          player.hp = 0;
          playExplosionSound();
          onGameOver();
          return;
        }
      }
    }

    // Va ch·∫°m th√¢n qu√°i -> player
    for (let i=enemies.length-1;i>=0;i--) {
      const e = enemies[i];
      const circ = { x:e.x, y:e.y, radius:Math.max(e.width,e.height)/2 };
      if (rectCircleColliding(circ, player)) {
        player.hp -= e.damage*0.7;
        e.hitTimer = 0.12;
        enemies.splice(i,1);
        sfxPlayerHit();
        if (player.hp <= 0) {
          player.hp = 0;
          playExplosionSound();
          onGameOver();
          return;
        }
      }
    }

    if (enemies.length===0 && gameState==='playing') onStageClear();
  }

  function onStageClear() {
    if (stage > progress.bestStage) { progress.bestStage = stage; saveProgress(); }
    sfxStageClearLaugh();
    spawnFireworks();
    showStageClear();
  }
  function onGameOver() {
    if (stage > progress.bestStage) { progress.bestStage = stage; saveProgress(); }
    sfxGameOverTease();
    showGameOver();
  }

  // ===== BACKGROUND: SKY SCROLL =====
  const STAR_COUNT = 60;
  const stars = [];
  function initStars() {
    stars.length = 0;
    for (let i=0;i<STAR_COUNT;i++) {
      stars.push({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        speed: 25 + Math.random()*40,
        size: 1 + Math.random()*1.5,
        alpha: 0.25 + Math.random()*0.5
      });
    }
  }
  function updateStars(dt) {
    for (const s of stars) {
      s.y += s.speed * dt;
      if (s.y > canvas.height) s.y -= canvas.height;
    }
  }
  function drawBackground() {
    const grd = ctx.createLinearGradient(0,0,0,canvas.height);
    grd.addColorStop(0, '#141b3a');
    grd.addColorStop(0.4,'#050a18');
    grd.addColorStop(1, '#020309');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.save();
    ctx.fillStyle = '#ffffff';
    for (const s of stars) {
      ctx.globalAlpha = s.alpha;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // ===== FIREWORKS (ph√°o hoa khi clear) =====
  let fireworks = [];
  function spawnFireworks() {
    fireworks = [];
    for (let i = 0; i < 7; i++) {
      const cx = Math.random() * canvas.width;
      const cy = 180 + Math.random() * 120;
      const particles = [];
      for (let j = 0; j < 30; j++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 80 + Math.random()*120;
        particles.push({
          x: cx,
          y: cy,
          vx: Math.cos(angle)*speed,
          vy: Math.sin(angle)*speed,
          alpha: 1
        });
      }
      fireworks.push({ life: 1.2, particles });
    }
    playExplosionSound();
  }

  function updateFireworks(dt) {
    for (const fw of fireworks) {
      fw.life -= dt;
      for (const p of fw.particles) {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 10 * dt;
        p.alpha -= dt * 1.2;
      }
      fw.particles = fw.particles.filter(p => p.alpha > 0);
    }
    fireworks = fireworks.filter(fw => fw.life > 0 && fw.particles.length > 0);
  }

  function drawFireworks() {
    ctx.save();
    for (const fw of fireworks) {
      for (const p of fw.particles) {
        ctx.globalAlpha = Math.max(0, p.alpha);
        ctx.fillStyle = '#ffdd55';
        ctx.fillRect(p.x, p.y, 3, 3);
      }
    }
    ctx.restore();
  }

  // ===== RENDER =====
  let globalTime = 0;

  function drawPlayer() {
    const w = player.width;
    const h = player.height;
    const t = globalTime;

    const bob  = Math.sin(t*4)*3;
    const tilt = player.moveDir * 0.25;

    ctx.save();
    ctx.translate(player.x, player.y + bob);
    ctx.rotate(tilt);

    if (isSpriteReady(spritePlayer)) {
      ctx.drawImage(spritePlayer, -w/2, -h/2, w, h);
    } else {
      ctx.fillStyle = '#66ff99';
      ctx.fillRect(-w/2, -h/2, w, h);
    }

    if (player.shootFlashTimer > 0) {
      const k = player.shootFlashTimer / 0.08;
      ctx.save();
      ctx.translate(w/2 - 10, -h/2 + 20);
      ctx.rotate(0.2);
      const len = 26 * k;
      const wid = 8  * k;
      const grd = ctx.createLinearGradient(0,-wid, len,wid);
      grd.addColorStop(0,'rgba(0,255,255,0.9)');
      grd.addColorStop(1,'rgba(0,255,255,0)');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.moveTo(0, -wid);
      ctx.lineTo(len, 0);
      ctx.lineTo(0, wid);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    ctx.restore();
  }

  function spriteForEnemy(e) { return (e.type==='boss'||e.type==='miniBoss') ? spriteBoss : spriteEnemy; }

  function drawEnemies() {
    const t = globalTime;
    enemies.forEach(e => {
      const w = e.width;
      const h = e.height;
      const baseBob = (e.type==='boss') ? 5 : 3;
      const bob  = Math.sin(t*3 + e.bobPhase) * baseBob;
      const tilt = Math.sin(t*2 + e.bobPhase*1.3) * 0.1;
      let scale = 1;
      if (e.type === 'boss')  scale = 1 + Math.sin(t*1.5 + e.bobPhase)*0.03;
      if (e.hitTimer > 0)     scale *= 1.06;

      ctx.save();
      ctx.translate(e.x, e.y + bob);
      ctx.rotate(tilt);
      ctx.scale(scale, scale);

      const spr = spriteForEnemy(e);
      if (isSpriteReady(spr)) {
        ctx.drawImage(spr, -w/2, -h/2, w, h);
      } else {
        ctx.fillStyle = e.type==='boss' ? '#ff4b5c' : (e.type==='miniBoss' ? '#ff9f43' : '#4af0ff');
        ctx.fillRect(-w/2, -h/2, w, h);
      }

      ctx.restore();

      const barW = w;
      const barH = 4;
      const pct = e.hp / e.maxHp;
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(e.x - barW/2, e.y - h/2 - 6, barW, barH);
      ctx.fillStyle = '#3cf06f';
      ctx.fillRect(e.x - barW/2, e.y - h/2 - 6, barW*pct, barH);
    });
  }

  function drawBullets() {
    ctx.fillStyle = '#ffeb3b';
    playerBullets.forEach(b => {
      ctx.beginPath(); ctx.arc(b.x,b.y,b.radius,0,Math.PI*2); ctx.fill();
    });
    ctx.fillStyle = '#ff5252';
    enemyBullets.forEach(b => {
      ctx.beginPath(); ctx.arc(b.x,b.y,b.radius,0,Math.PI*2); ctx.fill();
    });
  }

  function updateHud() {
    const hpPct = Math.max(0, Math.min(1, player.hp / player.maxHp));
    hpFill.style.width = (hpPct*100)+'%';
    hudHpText.textContent = Math.round(player.hp);
  }

  function drawFrame(dt) {
    drawBackground();
    drawPlayer();
    drawEnemies();
    drawBullets();
    drawFireworks();

    if (firestormFlashTimer > 0) {
      const alpha = Math.min(0.5, firestormFlashTimer / 0.25 * 0.5);
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = 'rgba(255,80,0,1)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.restore();
    }

    updateHud();
  }

  // ===== LOOP =====
  let lastTime = 0;
  function loop(ts) {
    const dt = Math.min(0.033,(ts-lastTime)/1000 || 0);
    lastTime = ts;
    globalTime = ts/1000;

    updateStars(dt);
    updateFireworks(dt);

    if (firestormFlashTimer > 0) {
      firestormFlashTimer -= dt;
      if (firestormFlashTimer < 0) firestormFlashTimer = 0;
    }

    if (gameState === 'playing') {
      updatePlayer(dt);
      updateEnemies(dt);
      updateBullets(dt);
      handleCollisions();
    }

    drawFrame(dt);
    requestAnimationFrame(loop);
  }

  // ===== INIT =====
  resetPlayer();
  initStars();
  updateFirestormHud();
  updateGoldHud();
  showMainMenu();
  requestAnimationFrame(loop);
</script>

</body>
</html>
